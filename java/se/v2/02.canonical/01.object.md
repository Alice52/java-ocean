## Object issue list

```java
Object obj = new Object();
```

![image](https://user-images.githubusercontent.com/42330329/112715733-0a9fcb00-8f1d-11eb-8a43-9b7d1a7aaf13.png)

![avatar](/static/image/java/javase-jvm-object.png)
![avatar](/static/image/java/javase-jvm-object-v2.png)

1. 对象的创建过程: 2,3 两步可以指令重排
   - new 分配空间
   - 初始化
   - 指向变量
2. 对象的内存布局
   - 普通对象
     1. [8-压缩无关]markword: 8byte{用于存储对象**自身**的**运行时**数据}
     2. [4/8]class pointer: 类型指针{指向 Object.class}, 4byte 或者 8byte; **UseCompressedClassPointers**
     3. instance data: 实例数据{对象内的属性数据} + java 基本数据类型的字节数
        - byte: 1byte
        - boolean: 1byte
        - char: 2byte
        - short: 2byte
        - int: 4byte
        - float: 4byte
        - double: 8byte
        - long: 8byte
        - [4/8]对象: 4/8byte, **UseCompressedOops**
     4. padding: 对齐{补齐为 8 的倍数}
   - 数组
     1. **[4-压缩无关]数组长度**: 4 字节且与压缩无关
     2. 以上的结构
3. 对象头的内容: markword + class pointer
   - class pointer: 类型指针
   - markword
     1. 哈希码: HashCode
     2. GC 信息: GC 分代年龄
     3. 锁信息: 锁状态标志/线程持有的锁/偏向线程 ID/偏向时间戳等等, 占用内存大小与虚拟机位长一致
4. 类型指针指向什么地方: 堆
5. 对象定位

   - 句柄池[指针池]: 间接指针, 节省内存{对象小}, GC 回收时不需要频繁修改 t; 两次访问{慢一点点}
   - 直接指针: 访问速度快

     1. 对象 o 直接指向堆中的地址
     2. 堆中的类型指针可以指向方法区的 T.class 获取相关属性

     ![avatar](/static/image/java/javaee-jvm-locate.png)

6. 对象分配过程

   - 首先尝试在 stack 上分配, 如果可以分配成功则就直接分配使用, 方法执行结束后该栈的空间会被直接回收{逃逸分析[该变量只被此栈帧内部使用]/标量替换}
   - 否则分配在堆中, 看对象大小, 判断是否直接分配在老年代中
   - 当不需要分配在老年区时, 判断大小看是否可以分配在线程内部{减小锁竞争}, 回收+S1/S2/老年区

   ![avatar](/static/image/java/javaee-jvm-allocate.png)

7. 为什么 hotspot 不使用 c++对象来代表 java 对象
   - c++ 的对象大于 java 对象{oop-classp[二元指针{堆-方法区[T.class]}]}
8. Class 对象是在堆还是在方法区
   - 在方法区中{本质是个引用[T.class 也是在堆中的]}
9. 对象的锁升级

   ![avatar](/static/image/java/javase-jvm-lock-upgrade.png)

10. 为什么会有偏向锁

    - 统计多数情况下只有一个线程在执行, 加重量级锁{向系统内核申请}太消耗资源
    - 直接将自己的线程 id 写入对象头, 比人也能知道该对象正在被使用{很少}, 效率高
    - 偏向锁默认是启动的, 但是会在 jvm 启动后延迟 4s[-XX:biasedLockingStartupDelay]
    - 偏向锁一定比自旋锁效率高吗? 不是[只有一个线程操作共享资源时效率是最高的]
      1. 如果明确知道有多个线程进行竞争, 就会直接使用自旋锁: 因为即使先使用了偏向锁, 之后还是要升级为自旋锁[加偏向锁和撤销偏向锁都是浪费]
      2. 延迟 4s: jvm 启动会有很多所竞争, 所以就不打开偏向锁了

11. 轻量级锁: 自旋锁 cas[**适应于被锁定后执行很快且线程数量比较少, 自旋次数比较少**]

    - 可以由无锁状态直接到达; 也可以由偏向锁升级而来
    - 偏向锁升级而来
      1. 将偏向锁驱逐, 大家一起抢{会优先照顾之前的那个偏向锁}
      2. 过程就是想自己的信息写入对象头[指针, 指向线程栈中的 Look Record]
      3. 其他没抢到的线程在自旋等待: cas, 空转 cpu 消耗资源

12. 重量级锁

    - 系统内核态参与
    - 执行时间长的方法

13. 批量重偏向&批量撤销: 不重要

    - 只有一个线程操作对象时偏向锁有很高的性能
    - 但是当多线程时就会有很大的性能消耗, 需要撤销偏向锁: 所以就产生了*批量重偏向&批量撤销*
    - 一个线程创建大量对象并执行了初始化的同步方法, 此时另外一个线程也要操作这些对象就会涉及大量的偏向锁撤销
    - 过程

      ![avatar](/static/image/java/javase-jvm-lock-explain.png)

## 18.new 一个对象的过程: 加载并初始化类和创建对象

1. 先查看对象所属的类有没有被加载到内存:

   - 没有则会先通过类的全限定名来加载
   - 有则进行对象的创建工作

2. 类加载过程[第一次使用该类]: **加载连接初始化**

   - 使用双亲委派模型来进行类的加载: **向上委托加载, 向下委托创建**

3. 创建对象: 分配空间+初始化+引用指向

   - 在堆区分配对象需要的内存: 分配的内存包括本类和父类的所有实例变量, 但不包括任何静态变量
     1. 指针碰撞: 使用复制算法或标记整理算法时, 内存区域都是规整的, 用过的内存放在一边, 空闲的内存在另一边, 中间用一个指针作为分界点, 当需要为新对象分配内存时只需把指针向空闲的一边移动一段与对象大小相等的距离
     2. 空闲列表: 使用标记清除算法时, 内存都是碎片化的, 那虚拟机就要记录哪块内存是可用的, 当需要分配内存时, 找一块足够大的内存空间给对象实例, 并更新记录
   - 对所有实例变量赋默认值等相关信息: 将方法区内对实例变量的定义拷贝一份到堆区, 然后赋默认值 + 设置对象头信息, 如所属类, 元数据信息, 哈希码, gc 分代年龄等等
   - 执行实例初始化代码: 初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法
   - 如果有类似于 Child c = new Child() 形式的 c 引用的话, 在栈区定义 Child 类型引用变量 c, 然后将堆区对象的地址赋值给它

4. others
   - 每个子类对象持有父类对象的引用, 可在内部通过 super 关键字来调用父类对象, 但在外部不可访问
   - 通过实例引用调用实例方法的时候, 先从方法区中对象的实际类型信息找, 找不到的话再去父类类型信息中找
   - 如果继承的层次比较深, 要调用的方法位于比较上层的父类, 则调用的效率是比较低的, 因为每次调用都要经过很多次查找. 这时候大多系统会采用一种称为虚方法表的方法来优化调用的效率
   - 虚方法表: 就是在类加载的时候, 为每个类创建一个表[该类的对象所有动态绑定的方法及其地址(包括父类的方法但一个方法只有一条记录), 子类重写了父类方法后只会保留子类的]. 当通过对象动态绑定方法的时候, 只需要查找这个表就可以了, 而不需要挨个查找每个父类

## 类加载: `加载-连接-初始化`

1. load

   - 根据类名获取二进制文件[findClass], 并转换为运行时数据结构[Class]
   - JVM 使用 `ClassName + PackageName + ClassLoader InstanceId`加载的类

2. link: 将加载到 JVM 中的二进制字节流的类数据信息合并到 JVM 的运行时状态中

   - 验证: **格式验证**[验证是否符合 class 文件规范], **语义验证**[final 子类问题, final 方法重写问题, 父子类间的方法签名问题(比如方法签名相同,但方法的返回值不同], **操作验证**[栈中的数据的操作, 常量池中的各种符号引用]
   - 准备: 为类的静态变量分配内存, 并将其`初始化为默认值`, final 修饰的 static 变量直接赋值
   - 解析: 把类中的`符号引用`转化为`直接引用`, 解析该类创建时对其他类的必要引用, 对类所有属性/方法进行解析[保证属性/方法存在以及具备应的权限 NoSuchMethodError/NoSuchFieldError]

3. [init](#class-initialization)

   - 先父后子
   - 为静态变量赋值
   - 执行 static 代码块

![avatar](https://user-images.githubusercontent.com/42330329/70802885-a7ecf380-1ded-11ea-8869-51282b8f8b1e.jpg)

## 双亲委派机制

![image](https://user-images.githubusercontent.com/42330329/112717216-1ba10a00-8f26-11eb-8109-899432a63a47.png)

1. 双亲委托模型的工作过程是：，每一个层次的类加载器都是如此，，
   使用双亲委托机制的好处是：

2. 定义&过程: `向上委托加载, 向下委托创建`

   - 如果一个类加载器 ClassLoader 收到了类加载的请求, 它首先看自己的缓存中是否存在[有则直接返回使用], 没有也不会自己去尝试加载这个类, 而是把这个请求委托给父类加载器去完成[先查询缓存], 因此所有的加载请求最终都应该传送到**顶层的启动类加载器**中, 只有当父类加载器反馈自己无法完成这个加载请求[它的搜索范围中没有找到所需要加载的类]时, 子加载器才会尝试自己去加载
   - 因此想使用某个类时会优先从 bootstrap 开始寻找可使用的类[bootstrap 中都没有则说明该类未被加载过], 找不到会去相应的子类寻找
   - 在 AppClassLoader 中找不到时则向下委托创建[由它到指定的文件系统或网络等 URL 中加载该类],
   - 最终都没有的话则会抛出 ClassNotFoundException
   - [双亲委派导致的]一个在第三方 jar 内的 class, 如果在自己的项目中重写了, 则会使用自己项目中的
     1. 自己项目在启动时 AppCL 会加载所有的类
     2. 使用该类是会优先使用上层的, 上层中能找到项目中自定义的, 所以不会使用第三方 jar 的 class

3. 优点:

   - 使自己创建的一些同名类不会污染源代码中的[比如重写了 Object 方法]
   - 能够有效确保一个类的全局唯一性, 当程序中出现多个限定名相同的类时, 类加载器在执行加载时, 始终只会加载其中的某一个类

4. core code

   ```java
    protected Class<?> loadClass(String name, boolean resolve)
       throws ClassNotFoundException
   {
       synchronized (getClassLoadingLock(name)) {
          // ⾸先，检查请求的类是否已经被加载过
           Class<?> c = findLoadedClass(name);
           if (c == null) {
               long t0 = System.nanoTime();
               try {
                   if (parent != null) {
                       c = parent.loadClass(name, false);
                   } else {
                       c = findBootstrapClassOrNull(name);
                   }
               } catch (ClassNotFoundException e) {
                   // ClassNotFoundException thrown if class not found
                   // from the non-null parent class loader
               }

               if (c == null) {
                   // If still not found, then invoke findClass in order
                   // to find the class.
                   long t1 = System.nanoTime();
                   c = findClass(name);

                   // this is the defining class loader; record the stats
                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                   sun.misc.PerfCounter.getFindClasses().increment();
               }
           }

           // 热加载机制会将编译阶段可以抛出的问题转移到运行时
           if (resolve) {
               resolveClass(c);
           }
           return c;
       }
   }
   ```

5. 打破双亲委派机制: 重写 loadClass 实现优先加载

   ```java
   // 在这里打破双亲委派机制: 此时的原系统中的 Class 与第三方的 Class 不能互转
   @Override
   public Class<?> loadClass(String name) throws ClassNotFoundException {
    // 在使用该类的时候, 发现符合规则, 就直接加载, 不走双亲委派机制
    if (name.startsWith("cn.edu.ntu")) {
      return findClass(name);
    }

    return super.loadClass(name);
   }
   ```

## new Object() 占多数字节

1. java8 默认开启 UseCompressedClassPointers 会压缩 cp, UseCompressedOops 会压缩实例数据
2. 对象结构: 对象头[8byte] + 类型指针 [8 字节-4byte] + 实例数据 + 对齐[0]
3. 且最终结果需要时 8 的倍数
4. 结论:

   ```java
   new Object(); //用压缩:  8 + 4 + 0 + 0 = 12 >> 16
   new Object(); //不压缩:  8 + 8 + 0 + 0 = 16
   new int[]{};  //用压缩:  8 + 4 + 4[length字段] + 0 = 16
   new int[]{};  //不压缩:  8 + 8 + 4[length字段] + 0 = 20 >> 24
   ```

5. 普通对象:

   - 对象头: markword 8 个字节, 锁定对象信息 + GC 标记[分代年龄]只能用 4bit 最大表示 15 所以 GC 年龄默认为 15
   - ClassPointer 指针: `-XX:+UseCompressedClassPointers` 为 4 字节 不开启为 8 字节
   - 实例数据:

     1. 引用类型: `-XX:+UseCompressedOops` 为 4 字节 不开启为 8 字节[Oops Ordinary Object Pointers]

   - Padding 对齐, 使成为 8 的倍数

6. 数组对象

   - 对象头: markword 8 个字节且与压缩无关
   - ClassPointer 指针
   - 数组长度: 4 字节且与压缩无关
   - 数组数据
   - 对齐 8 的倍数

7. 对象定位问题

   - 句柄池[指针池]: 间接指针, 节省内存
   - 直接指针: 访问速度快

## Object 里常见方法

### 1. registerNatives()

### 2. getClass()

### 3. hashCode()

1. Object 的 equals 使用的是 `this == obj` 比较的是地址, 所以默认保证了上面的要求
2. 如果不这样做的话，就会违反 Object.hashCode 的**通用的约定**
   - 任何时候调用一个对象的 hashCode 方法, 返回的值必须一样
   - 两个对象的 equals 相等则每个对象的 hashcode 的值必须相同
   - 非必须: 如果两个对象不相等, 则 hashcode 方法返回值也不相同
3. 重写 equals 一定要重写 hashcode, 为了保证 `两个对象 equals 相同则 hashcode 一定相等`
4. hashcode 相同但是 equals 不一定相同: Integer 的 hashcode 返回值本身, 但是 string 类型的 hashcode 返回值可与其相等
   - 比如 Integer 的 hashcode 重写为右移两位[equals 不动(比较的是值)], 则 5 和 7 的 hashcode 相等, 但是 equals 不懂
   - 且符合 JDK 关于 hashcode 的此案 GG 约束: hashcode 和具体实现相关, 不能保证一定做到对象不同则 hashcode 一定不同, 因此上面说的是一个垃圾的 hash 算法
5. hashcode 不同则 equals 一定不同

### 4. equals(Object obj)

1. 对于 ==

   > 如果作用于基本数据类型的变量, 则直接比较其存储的 "值" 是否相等;
   > 如果作用于引用类型的变量, 则比较的是所指向的对象的地址

2. equals() 方法是 Object 类的方法, 由于所有类都继承 Object 类, 也就继承了 equals() 方法.

   - equals 方法不能作用于基本数据类型的变量.
   - 如果没有对 equals 方法进行重写, 则比较的是引用类型的变量所指向的对象的地址;
   - 诸如 String、Date 等类对 equals 方法进行了重写的话, 比较的是所指向的对象的内容.

3. 重写 equals() 就要重写 hashcode()

   - 当两个对象 equals 比较为 true, 那么 hashcode 值应当相等, 反之亦然, 因为当两个对象 hashcode 值相等, 但是 equals 比较为 false
   - 成对重写, 即重写 equals 就应当重写 hashcode.

### 5. clone()

1. 是 native 的方法, 是浅拷贝: `x.clone() != x`
   - BeanUtils 是浅拷贝
   - ArrayList#subList() 是浅拷贝
2. 深拷贝的实现方式
   - 序列化 IO 操作: https://www.jianshu.com/p/69027afc0adc
   - json util
   - 实现内部对象的 clone()
   - ~~递归 clone 知道是基本对象~~
3. 深拷贝的使用场景
   - 原型模式

### 6. toString()

1. toString() 方法在 Object 类中定义, 其返回值是 String 类型, 返回类名和它的引用地址.
   `这里需要注意的是 ArrayList<Person> : Person 的 toString 方法会被迭代`

### 7. notify() / notifyAll()

### 8. wait() / wait(long timeout) / wait(long timeout, int nanos)

### 9. finalize()
