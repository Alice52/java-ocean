## 公平锁/非公平锁

1. 概念

   - 公平锁: 指多个线程按照申请锁的顺序获取锁, 类似与排队打饭[FIFO]
   - 非公平锁: 指多个线程获取锁的顺序不一定时申请锁的顺序, 通过竞争获取锁: 可能优先级反转, 或者饥饿

2. `ReentrantLock[默认]/synchronized 都是非公平锁`

   ```java
   // lock 的本质: 设置 AQS 的 state 和记录下当前排他的线程对象
   public ReentrantLock() {
       sync = new NonfairSync();
   }
   ```

3. 区别

   - 公平锁在并发的环境中每个线程在获取锁时会先查看此锁维护的等待队列, 如果为空, 则当前线程时等待队列的第一个, 就占有锁, 否则会加入等待队列 FIFO
   - 非公平锁会直接竞争尝试占有锁, 如果失败则会采用类似公平锁那种方式
   - 非公平锁优点是吞吐量大, 公平锁是有序的 FIFO

4. 公平锁流程

   - 线程尝试获取锁: tryAcquire

     1. 根据 AQS 的 state 判断能否获取到锁
     2. 有一个可重入锁的设置: state = 2

   - 获取锁失败后则加入 queue tail

     1. 尝试加入 queue tail
     2. 失败则自旋, 直到成功

   - 尝试让 head 获取锁

     1. 判断刚才加的那一个是不是 head: 是则尝试让他获取锁
     2. 不是的话, 则调用 LockSupport.park() 方法去阻塞

   - 当前线程执行完成, 会指定唤醒 LockSupport.unpark() 队首的线程, 让其去获取锁
   - interrupt() 方法

## 可重入锁[递归锁]

1. 概念

   - 指同一线程外层函数获取锁之后, 内层递归函数仍可以获取被该锁锁住的代码[即使内部还有锁]
   - 同一线程在外层获取锁的之后, 在进入到内层方法会自动获取锁
   - `线程可以进入任何一个它已经拥有的锁所同步着的代码块`: **`同步方法可以进入内部调用的同步方法`**
   - 好处: 避免死锁

2. `ReentrantLock/synchronized 都是可重入锁`

   ```java
   // 最终调用到 setV2 方法时, setV2 执行也是同步的
   private static synchronized void get() {
       log.info("thread: {} synchronized -- get", Thread.currentThread().getName());
       set();
   }
   private static synchronized void set() {
       log.info("thread: {} synchronized -- set", Thread.currentThread().getName());
   }
   private static void setV2() {
       log.info("thread: {} synchronized -- get", Thread.currentThread().getName());
       set();
   }

   private static void m0() {
       try {
           lock.lock();
           lock.lock();
           log.info("thread: {} reentrant-lock -- m0", Thread.currentThread().getName());
           m1();
       } finally {
           lock.unlock();
           log.info("thread: {} reentrant-unlock -- m0", Thread.currentThread().getName());
           lock.unlock();
       }
   }
   private static void m1() {
       try {
           lock.lock();
           log.info("thread: {} reentrant-lock -- m1", Thread.currentThread().getName());
       } finally {
           log.info("thread: {} reentrant-unlock -- m1", Thread.currentThread().getName());
           lock.unlock();
       }
   }
   ```

3. synchronized 可重入的原理

   - 每个`锁对象`都拥有`一个计数器`和`一个`指向持有该锁线程的`指针`
   - 执行 monitorenter 时, 如果目标锁对象的计数器为 0, 则证明所对象没有被其他线程持有, 则 JVM 会将所对象的持有线程设置为此线程, 并对计数器加 1
   - 如果目标锁对象的计数器不为 0 且对对象的持有线程是当前线程, 则 JVM 对其计数器加 1, 否则需要等待锁释放[不可中断性]
   - 执行 monitor 时对计数器减 1, 且当计数器为 0 时清空锁对象的指针

4. ReentrantLock 可重入的原理: AQS state++

## 独占锁/共享锁: 读写锁

1. 概念: 读锁可共享, 写锁必排他

   - 独占锁: 该锁一次只能被一个线程持有, 保证数据一致安全`[读写, 写写, 写读, 读读都是互斥的]`
   - 共享锁: 该锁一次只能被多个线程持有, 保证并发读的高效: `[读读不互斥]`

2. `ReentrantLock/synchronized 都是独占锁`; `ReentrantReadWriteLock 的读锁时共享锁, 写锁则是独占锁`

   - 写 + 读: 等待写锁释放
   - 写 + 写: 阻塞写
   - 读 + 写: 等待写锁释放
   - 读 + 读: 无锁, 只会记录所有的读锁, 都能加锁成功

3. 物理: 红蜘蛛, 机场显示屏
4. 为什么要有读写锁: `读写如果都加锁的话[只有一个线程操作], 数据一致性可以保证但是并发性下降`

   ```java
   // 最终的打印结果与 for 的顺序十分相关
   @Slf4j
   public class RWLock {

       public static void main(String[] args) throws InterruptedException {

           MyCache cache = new MyCache();

           for (int i = 0; i < 9; i++) {
              int finalI = i;
              new Thread(() -> cache.setSafeV2("a" + finalI, finalI), "AAA" + i).start();
           }

           for (int i = 0; i < 9; i++) {
              int finalI = i;
              new Thread(() -> cache.getSafeV2("a" + finalI), "BBB" + i).start();
           }
       }
   }

   @Slf4j
   @Getter
   class MyCache {
       private volatile Map<String, Object> cache = new HashMap<>();
       private Lock lock = new ReentrantLock();
       private ReadWriteLock rwLock = new ReentrantReadWriteLock();

       /**
           * 这里的写操作会出现被打断的情况: 线程不安全
           *
           * @param key
           * @param value
           * @see cn.edu.ntu.javase.interview.list.UnsafeHashMap
           */
       @SneakyThrows
       public void set(String key, Object value) {
           log.info("thread: {} is writing key {}", Thread.currentThread().getName(), key);
           TimeUnit.MICROSECONDS.sleep(300);
           cache.put(key, value);
           log.info("thread: {} is write done", Thread.currentThread().getName());
       }

       @SneakyThrows
       public Object get(String key) {
           log.info("thread: {} is read key {}", Thread.currentThread().getName(), key);
           TimeUnit.MICROSECONDS.sleep(300);
           Object o = cache.get(key);
           log.info("thread: {} is read done {}", Thread.currentThread().getName(), o);
           return o;
       }

       /**
           * 写操作是线程安全的, 且只保证写操作的线程安全.<br>
           * 如果调用 set 非线程安全操作, 则会在写操作之间读操作的log<br>
           *
           * @param key
           * @param value
           */
       @SneakyThrows
       public void setSafe(String key, Object value) {
           lock.lock();
           try {
              log.info("thread: {} is writing key {}", Thread.currentThread().getName(), key);
              TimeUnit.MICROSECONDS.sleep(300);
              cache.put(key, value);
              log.info("thread: {} is write done", Thread.currentThread().getName());
           } finally {
             lock.unlock();
           }
       }

       @SneakyThrows
       public Object getSafe(String key) {
           lock.lock();
           try {
              log.info("thread: {} is read key {}", Thread.currentThread().getName(), key);
              TimeUnit.MICROSECONDS.sleep(300);
              Object o = cache.get(key);
              log.info("thread: {} is read done {}", Thread.currentThread().getName(), o);
              return o;
           } finally {
              lock.unlock();
           }
       }

       /**
           * 写锁是独占锁: 原子 + 独占
           *
           * @param key
           * @param value
           */
       @SneakyThrows
       public void setSafeV2(String key, Object value) {
           rwLock.writeLock().lock();
           try {
              log.info("thread: {} is writing key {}", Thread.currentThread().getName(), key);
              TimeUnit.MICROSECONDS.sleep(300);
              cache.put(key, value);
              log.info("thread: {} is write done", Thread.currentThread().getName());
           } finally {
              rwLock.writeLock().unlock();
           }
       }

       /**
           * 读锁是共享锁
           *
           * @param key
           * @return
           */
       @SneakyThrows
       public Object getSafeV2(String key) {
           rwLock.readLock().lock();
           try {
              log.info("thread: {} is read key {}", Thread.currentThread().getName(), key);
              TimeUnit.MICROSECONDS.sleep(300);
              Object o = cache.get(key);
              log.info("thread: {} is read done {}", Thread.currentThread().getName(), o);
              return o;
           } finally {
              rwLock.readLock().unlock();
           }
       }
   }
   ```

## 自旋锁(cas)

1. 概念

   - 指尝试获取锁的线程不会立即阻塞, 而是采用循环的方式去尝试获取锁
   - 好处: 较少的上下文切换的开销, 缺点是长时间自旋会消耗 CPU
   - AtomicInteger 这些类底层都是 cas+自旋锁

2. 手写自旋锁: `cas+while-loop`

   ```java
   public class SpinLock {

       /**
       * 此时没有被调用所以之内存中还是 null<br>
       * 基本数据类型, new 出来时是默认值,<br>
       * 引用类型则是 null
       */
       // 也可以使用 int 定义0 为锁空闲, 1 表示锁被占有: 比如源码中的 state
       private AtomicReference<Thread> reference = new AtomicReference<>();

       private void Lock() {
           log.info("thread: {} try get lock", Thread.currentThread().getName());

           // 成功比较并设置则停止循环
           while (!reference.compareAndSet(null, Thread.currentThread())) {
               // logic
               log.info("thread: {} do-while", Thread.currentThread().getName());
           }
       }

       private void UnLock() {
           reference.compareAndSet(Thread.currentThread(), null);
           log.info("thread: {} unlock", Thread.currentThread().getName());
       }

       @SneakyThrows
       public static void main(String[] args) {
           SpinLock lock = new SpinLock();

           new Thread(() -> {
                           lock.Lock();
                           TimeUnit.SECONDS.sleep(5);
                       } finally {
                           lock.UnLock();
                       }, "AAA").start();

           // 保证 AAA 先获取到锁
           TimeUnit.SECONDS.sleep(1);

           new Thread(() -> {
                       lock.Lock();
                       TimeUnit.SECONDS.sleep(1);
                   } finally {
                       lock.UnLock();
                   }, "BBB").start();
       }
   }
   ```

## 死锁

1. 定义: 死锁是指`两个及以上`的进程在执行过程中, 因争夺`相同资源`而造成的一种`相互等待`的现象, 若无外力干涉那他们都将`无法推进`下去
2. 产生原因

   - 系统资源不足
   - 进程运行推进的顺序不合适
   - 资源分配不当

3. 写一个死锁

   ```java
   public static void main(String[] args) {
       DeadResource deadLock = new DeadResource();
       new Thread(() -> deadLock.addWithR1Lock(), "R1").start();
       new Thread(() -> deadLock.addWithR2Lock(), "R2").start();
   }

   static class DeadResource {

     String r1Lock = "1";
     String r2Lock = "2";

     @SneakyThrows
     public void addWithR1Lock() {
       synchronized (r1Lock) {

         // 为了让 addWithR2Lock 获取 r2Lock 锁
         TimeUnit.SECONDS.sleep(2);

         synchronized (r2Lock) {
           log.info("execute method of addWithR1Lock.");
         }
       }
     }

     @SneakyThrows
     public void addWithR2Lock() {
       synchronized (r2Lock) {
         // 为了让 addWithR1Lock 获取 r2Lock 锁
         TimeUnit.SECONDS.sleep(2);
         synchronized (r1Lock) {
           log.info("execute method of addWithR2Lock.");
         }
       }
     }
   }
   ```

4. 怎么证明此代码是死锁

   ```shell
   jps -l
   jstack PID
   # Found 1 deadlock.
   ```

## 锁升级

1. flow

   ![avatar](/static/image/java/javase-juc-lock-upgrate.png)
   ![avatar](/static/image/java/javase-juc-lock.png)

   ```java
   public static void main(String[] args) {
       // 1. 无锁: 创建出一个对象默认就是无锁状态
       // 反向的获取 对应 图片的顺序
       Person tmpPerson = new Person();
       // 00000000 00000000 00000000 00000001
       log.info("无锁状态(001): {}", ClassLayout.parseInstance(tmpPerson).toPrintable());

       // 2. 偏向锁: 改线程5s 之后创建的对象会变为偏向锁
       // 2.1 可以通过 -XX:BiasedLockingStartupDelay=0 取消延时; 可以通过 -XX:-UseBiasedLocking=false 取消偏向锁
       TimeUnit.SECONDS.sleep(5);
       Person p1 = new Person();
       // 00000000 00000000 00000000 00000101
       log.info("偏向锁状态(101): {}", ClassLayout.parseInstance(p1).toPrintable());

       // 2.2 偏向锁加锁会将线程ID写入对象头
       synchronized (p1) {
         // 00000011 00010101 00111000 00000101
         log.info("偏向锁状态(101) With Thread-ID: {}", ClassLayout.parseInstance(p1).toPrintable());
       }
       // 2.3 偏向锁释放不会将线程ID移出对象头: 偏向此线程; 所以结果与上一次完全相同(00000011 00010101 00111000 00000101)
       log.info("偏向锁状态(101) With Thread-ID 释放: {}", ClassLayout.parseInstance(p1).toPrintable());

       // 3. 轻量级锁: 多个线程加锁竞争[轻度](两个线程对同一个对象加锁就会升级为轻量级锁)
       // 3.1 指向 monitor, 且会把对象分带年龄存入其他的地方, 解锁的时候会写回来
       new Thread(() -> {
                 synchronized (p1) {
                   // 00011111 11011100 11110100 01000000
                   log.info("轻量级锁状态(00): {}", ClassLayout.parseInstance(p1).toPrintable());
                   // 不释放锁, 下面的锁会默认自旋10次[会有自适应调节], 升级为重量级锁
                   TimeUnit.SECONDS.sleep(5);
                 }
               }).start();

       // 4. 重量级锁: 重度竞争[自适应自旋(默认10次)], 轻量级锁会升级为重量级锁
       // 4.1 指向 monitor, 且会把对象分带年龄存入其他的地方, 解锁的时候会写回来
       new Thread(() -> {
                 synchronized (p1) {
                   // 00011100 10101000 11110100 11111010
                   log.info("重量级锁状态(10): {}", ClassLayout.parseInstance(p1).toPrintable());
                 }
               }).start();

       TimeUnit.SECONDS.sleep(15);

       // 5. 锁释放:
       // 5.1 偏向锁锁的释放前后没有任何改变
       // 5.2 轻量级锁的释放会完全释放至无锁状态
       // 5.3 重量级锁的释放会完全释放至无锁状态
       // 00000000 00000000 00000000 00000001
       log.info("所释放后的无锁状态(001): {}", ClassLayout.parseInstance(p1).toPrintable());
     }
   ```

2. 对象的构成: 对象头 + 实例数据 + 对齐
   - link: se/thread-advance/interview/01.raw-question.md

## [8 lock](https://blog.csdn.net/qq_31748587/article/details/105498566)

1. lock.lock() 一定要写在 try 外面, unlock() 写在 finally 里
2. lock type
   - 实例对象锁： 所得是当前的实例 this [产品个体]
   - 类锁： 锁定整个 class, 即所有实例 [产品工厂]
     > 产品个体 和 产品工厂 是两个独立的东西, 互不干扰
3. lock explain
   - 一个对象里面如果有多个 synchronized 方法, 在某一时刻, 只要一个线程去调用其中的一个 synchronized 方法, 其他线程都只能等待。
   - `[在某一时刻内, 只能有一个线程去访问这些 synchronized 的方法, **锁的是当前的对象**, 被锁定后, 其他线程都不能进入到当前对象的其他 synchronized 方法]`
   - 资源类内添加普通方法[非同步方法], 普通方法与锁无关, 会直接执行
   - 两个资源类, 两个同步方法, 则两个线程分别使用不同的资源类导致不是同一把锁, 所以彼此互不相关
   - 两个静态同步方法, 无论资源个数, 都会按调用的顺序执行 `[static 锁的是类加载器中的模板, 即所有这个类的实例]`
   - 一个静态的锁方法, 一个普通锁方法, new 一个对象调用: 锁的不是一个对象, 不会阻塞
   - 普通的非静态方法使用 xx.class, 无论资源个数, 同一时间只能有一个在执行
