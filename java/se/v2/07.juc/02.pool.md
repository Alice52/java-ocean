#### 线程池-Executors

1. Executors.newFixedThreadPool(10): `LinkedBlockingQueue`

   - 创建一个定长的线程池: core == pool-max == 10, 都不可以回收
   - 实现控制线程的最大并发数
   - 不使用的原因: LinkedBlockingQueue 超出的任务会在 queue 里等待[queue 无限大]
   - 适用: 执行`一个`长期的`任务`, 性能好很多
   - Queue 无限长会导致 OOM

2. Executors.newCachedThreadPool(): `SynchronousQueue`

   - 创建一个可以缓存的线程池: core = 0, pool-max == Integer.MAX_VALUE 都可以回收
   - 如果线程池长度超过处理需要, 可以灵活的回收线程
   - 若无可回收则新建线程
   - 不使用的原因: 线程数量可以 Integer.MAX_VALUE
   - 适用: 执行很多`短期异步`的小程序或者`负载较轻`的服务器
   - 会创建很多线程导致 CPU 100% 且线程数量过多的话也会导致 OOM

3. Executors.newScheduledThreadPool(10): `DelayedWorkQueue`

   - 创建一个定长的线程池: core == 10, pool-max == Integer.MAX_VALUE, 大于 core 的可以回收
   - 支持定时和周期任务的执行
   - 不使用的原因: 线程数量可以 Integer.MAX_VALUE

4. Executors.newSingleThreadExecutor(): `LinkedBlockingQueue`

   - 创建一个单线程化的线程池: core = max = 1, 不可以回收
   - 只会使用唯一的线程来工作
   - 不使用的原因: LinkedBlockingQueue 超出的任务会在 queue 里等待[queue 无限大]
   - 适用: `一个任务`一个线程执行的任务场景
   - Queue 无限长会导致 OOM

5. Executors.newWorkStealingPool(int):

   - java8 新增, 使用目前机器上可以的处理器作为他的并行级别

6. executor.shutdown();
7. submit()/**execute**()
   - 阻塞: 都不阻塞
   - 参数: execute(Runnable) | submit(XX) 最终都会包装成 RunnableFuture
   - 返回值: excute() 没有返回值 | submit() 存在返回值
   - 异常: excute() 的异常信息会被 Thread.UncaughtExceptionHandler 处理 | submit 的异常信息会被封装到 Feature 内, 使用 get 会抛出
8. 线程池异常处理

   - 手动 try..catch
   - ThreadPoolExecutor#afterExecute
   - UncaughtExceptionHandler: 不配置的话也会 log 出异常(默认只在控制台)
     - 处理异常的顺序:
       1. 当前线程有异常处理器
       2. 当前线程所属的线程组有异常处理器
       3. 全局默认的 DefaultUncaughtExceptionHandler: 只会出现在 console, log 文件中没有
       4. 子线程就直接退出: 此时会出现逻辑没有执行, 且没有捕获异常的 log
   - Thread.setUncaughtExceptionHandler 设置当前线程的异常处理器
   - Thread.setDefaultUncaughtExceptionHandler 为整个程序设置默认的异常处理器
   - Future 的 get/join 可以把异常直接抛出来
   - **CF 下的只能使用 exceptionally 中获取异常**: 在内部被 catch 过

9. 线程池内线程出现非捕获异常: 线程池的稳定性和可靠性(不会使线程减少)

   - 异常捕获: 线程池会捕获线程抛出的异常, 防止异常传播到线程外部导致程序中断
   - 线程移除(即使指定线程的异常处理器): 异常发生后, 线程池会将出现异常的线程从线程池中移除, 以避免该线程继续执行其他任务
   - 线程替换: 线程池会创建一个新的线程来替换被移除的异常线程, 以保持线程池的稳定性和预设的线程数量

#### 线程池-ThreadPoolExecutor

##### 状态

1. Running: 可以接受任务和处理已添加的任务
2. Shutdown: 不接受新的任务, 可以处理已添加的任务
3. Stop: 不接受新的任务, 不处理已添加的任务, 且中断正在执行的任务
4. Tidying: 所有的任务都已经终止, ctl 记录的任务数量为 0, ctl[负责记录线程池的运行状态和活动线程的数量]
5. Terminated: 线程池彻底终止

   ```java
   // 一个 Integer 32 bit: 前三bit 表示线程池的状态; 后面的29bit表示当前工作线程的数量
   private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
   private static final int COUNT_BITS = Integer.SIZE - 3;
   private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

   // runState is stored in the high-order bits
   private static final int RUNNING    = -1 << COUNT_BITS;  // 111x xxxx xxxx xxxx xxxx xxxx xxxx xxxx
   private static final int SHUTDOWN   =  0 << COUNT_BITS;  // 000x xxxx xxxx xxxx xxxx xxxx xxxx xxxx
   private static final int STOP       =  1 << COUNT_BITS;  // 001x xxxx xxxx xxxx xxxx xxxx xxxx xxxx
   private static final int TIDYING    =  2 << COUNT_BITS;  // 010x xxxx xxxx xxxx xxxx xxxx xxxx xxxx
   private static final int TERMINATED =  3 << COUNT_BITS;  // 011x xxxx xxxx xxxx xxxx xxxx xxxx xxxx
   ```

##### flow

1. 线程池创建, 准备好 core 数量的核心线程, 准备接受任务
2. 新的任务进来, 用 core 准备好的空闲线程执行
   - core 满了, 九江再进来的任务放入阻塞队列, 空闲的 core 就会自己去 queue 中回去任务并执行
   - queue 满了, 才会开新的线程执行, 直到达到线程的最大数量
   - 如果线程数量已是 max, 还有新的任务进来[且 queue 满了, 否则会放入 queue], 就会使用 handler 进行拒绝
   - 任务执行完了, max 个数的线程空闲下来, 则 max - core 个线程会在 keepAliveTime 之后被释放掉， 最终使得线程数量达到 core 个
3. 所有的线程都是由指定的 factory 创建的
4. interview： 一个线程池 core: 7, max: 20, queue: 50, 此时 100 并发

   - 先有 7 个能被直接被执行
   - 50 个进入 queue
   - 之后开 13 个线程继续执行: **这里的执行可能早于 queue 中的**
   - 余下的 30 个使用 handler 进行拒绝
   - **提交优先级: core -- queue -- new thread**
   - **执行优先级: core -- new thread -- queue**

5. core

   - [flow diagram](https://www.processon.com/view/5ffe4c0c7d9c080e58bec180)

   ```java
   public void execute(Runnable command) {
       if (command == null)
           throw new NullPointerException();

       int c = ctl.get();
       // 当前线程总数小于 core-pool-size 则创建线程执行
       if (workerCountOf(c) < corePoolSize) {
           if (addWorker(command, true))
               return;
           c = ctl.get();
       }
       // core-pool-size 最大则入 queue
       if (isRunning(c) && workQueue.offer(command)) {
           int recheck = ctl.get();
           if (! isRunning(recheck) && remove(command))
               reject(command);
           else if (workerCountOf(recheck) == 0)
               addWorker(null, false);
       }
       // 如果入 queue 失败或者使用 SynchronousQueue 则执行 reject
       else if (!addWorker(command, false))
           reject(command);
   }
   ```

   ![avatar](/static/image/java/thread-pool-executor.png)
   ![avatar](/static/image/java/javase-juc-submit.png)
   ![avatar](/static/image/java/javase-juc-execute-flow.png)

#### 7 parameters

1. `@param corePoolSize`:
   - 一直存在[除非线程池销毁或者设置{@code allowCoreThreadTimeOut}],
   - 线程池创建好之后就准备就绪的线程数量, 等到接受异步任务去执行
2. `@param maximumPoolSize`: 最多线程数量, 控制资源
3. `@param keepAliveTime`:
   - 当前线程数大于核心线程数后,
   - 如果线程空闲大于 keepAliveTime 就会释放该线程,
   - 释放的线程时 `maximumPoolSize - corePoolSize`
4. `@param unit`: keepAliveTime 的时间单位
5. `@param blockingQueue`: 如果任务很多, 则多出来的将任务放入 queue 里, 只要有线程空闲了就会从 queue 里取出任务执行

   - {@link SynchronousQueue } 没有容量:
     1. 每一个插入操作都需要等待相应的删除操作, 反之亦然;
     2. 不会真的保存任务, 总是将任务直接交给线程执行, 没有空闲线程则创建新的线程, 线程数量达到最大值则使用 rejectHandler;
     3. 使用时建议设置很大的 pool-size
   - {@link ArrayBlockingQueue(int size) }:
     1. 如果有新的任务进来则就交给空闲线程执行;
     2. < core-pol-size 则创建新的线程执行,
     3. > core-pol-size, 则加入 queue
     4. queue 满了则 reject-handler
   - {@link LinkedBlockingDeque(int capacity)}:
     1. 容量默认是 Integer 的最大值[一定要限制]: 使用时一定要设置容量
     2. 如果有新的任务进来则就交给空闲线程执行;
     3. < core-pol-size 则创建新的线程执行,
     4. > core-pol-size, 则加入 queue
     5. queue 满了则 reject-handler
   - {@link java.util.PriorityQueue(int capacity) }: 控制任务执行顺序

6. `@param threadFactory`: 线程创建工厂
7. `@param handler`: 如果队列满了且达到了最大 pool-size, 就使用指定的策略拒绝向 queue 里放任务
   - [默认]AbortPolicy: 直接丢弃新的任务, throw exception
   - DiscardPolicy: 直接丢弃新的任务, 不 throw exception
   - DiscardOldestPolicy: 丢弃最老的任务
   - CallerRunsPolicy: 转为同步调用
   - 实现 `RejectedExecutionHandler` 进行自定义

#### CompletetableFuture

1. 创建一个异步操作

   - 没有指定 Executor 的方法会使用 `ForkJoinPool.commonPool()` 作为它的线程池执行异步代码

   ```java
   // 1. runAsync: 异步执行没有返回值
   public static CompletableFuture<Void> runAsync(Runnable runnable)
   public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)
   // 2. supplyAsync: 异步执行有返回值, get() 获取结果
   public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
   public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)
   ```

2. 线程串行化

   ```java
   // 1. thenRun: 不能获取上一步的执行结果
   public CompletableFuture<Void> thenRun(Runnable action)
   public CompletableFuture<Void> thenRunAsync(Runnable action)
   public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor)

   // 2. thenAcceptAsync: 能接受上一步结果, 但是无返回值
   public CompletableFuture<Void> thenAccept(Consumer<? super T> action)
   public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action)
   public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor)

   // 3. thenApplyAsync: 能接受上一步结果, 有返回值
   public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)
   public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn)
   public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)
   ```

3. 计算结果完成时的回调方法

   ```java
   // 可以处理异常, 不能处理异常时返回值
   public CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> action)
   public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)
   public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)
   //可以处理异常, 能处理异常时返回值
   public CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn)
   ```

4. handle 方法: handle 是执行任务完成时对结果的处理

   ```java
   // 可以感知异常, 并能处理异常时返回值
   // handle就像finally, 不论正常返回还是出异常都会进入handle, 类似whenComplete
   //   handle: T -> R
   //   whenComplete的返回值和上级任务传入的结果一致, 不能对其转换
   public <U> CompletionStage<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);
   public <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);
   public <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn,  Executor executor)
   ```

   ```java
    public static void main(String[] args) throws ExecutionException, InterruptedException {
       DeptService deptService = new DeptService();
       UserService userService = new UserService();

       CompletableFuture<User> future = CompletableFuture
            .supplyAsync(() -> deptService.getById(1)})
            .handle((Dept dept, Throwable throwable) -> {
                    if (throwable != null){
                        System.out.println(throwable.getMessage());
                        return null;
                    }
                    User user = new User(1, "winter", 32, dept.getId(), dept.getName());
                    return userService.save(user);
                }
            );
   }
   ```

5. 组合任务: **被组合的是异步的则需要** join， cf.getNow(null) 得到的就是 null

   ```java
   // 1. thenCombine 组合两个 Future{异步执行}, 获取两个 future 的结果, 并返回当前任务的结果
   public <U,V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)
   public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)
   public <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor)

   // 2. thenAcceptBoth 组合两个 Future, 获取两个 future 的结果, 执行当前任务, 无返回值
   public <U> CompletionStage<Void> thenAcceptBoth(CompletionStage<? extends U> other,BiConsumer<? super T, ? super U> action);
   public <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage<? extends U> other,BiConsumer<? super T, ? super U> action);
   public <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage<? extends U> other,BiConsumer<? super T, ? super U> action,     Executor executor);

   // 3. runAfterBoth 组合两个 Future, 不能获取两个 future 的结果, 执行当前任务, 无返回值
   public CompletionStage<Void> runAfterBoth(CompletionStage<?> other,Runnable action);
   public CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action);
   public CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action,Executor executor);

    // 4. applyToEither: 两个任务有一个之下能够完成后, 获取其返回值, 执行当前任务, 有返回值
    public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other, Function<? super T, U> fn)
    public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn)
    public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn, Executor executor)

    // 5. acceptEither: 两个任务有一个之下能够完成后, 获取其返回值, 执行当前任务, 无返回值
    public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action)
    public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action)
    public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor)

   // 6. runAfterEither 两个任务有一个之下能够完成后, 不能获取其返回值, 执行当前任务, 无返回值
   public CompletionStage<Void> runAfterEither(CompletionStage<?> other,Runnable action);
   public CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action);
   public CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action,Executor executor);

   // 7. thenCompose 方法允许你对两个 CompletionStage 进行流水线操作，第一个操作完成时，将其结果作为参数传递给第二个操作
   public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn);
   public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn) ;
   public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends CompletionStage<U>> fn,Executor executor);

   // 8. allOf 等待所有任务完成
   public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)

   // 9. anyOf 只要有一个任务完成, 可以拿到该执行完成后的结果 get()
   public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)
   ```

6. sample

   ```java
   // 异步执行两个任务后得到结果, 做计算并返回
   return supplyAsync(() -> countParticipantInScope(currentMemberId, activity))
           .thenCombine(supplyAsync(() -> getCurrentRank(currentMemberId, activity))
                   ,(count, rank) -> setCR(count, rank, basicInfoVO))
           .get();
   ```
