## AQS: AbstractQueuedSynchronizer/AbstractOwnableSynchronizer/AbstractQueuedLongSynchronizer

![avatar](/static/image/java/javase-juc-aqs.bmp)

1. 简介

   - Abstract: 符合模板模式, 核心父类被集成, 形成钩子调用
   - Queued: 对抢不到锁的线程的管理
   - Synchronizer: 尝试去抢占锁, 管理好在排队的暂时没有抢到锁的线程
   - 用来构建锁[ReentrantLock]和其他同步器组件[CountDownLatch/CyclicBarrier/Semapthore]的基石[framework]
   - 通过内置的 queue[CLH] 来完成线程的排队管理工作, 并通过一个 int 型变量表示锁的持有[volatile state]

2. 简介 2

   - 已获取锁的线程执行逻辑, 其他抢占锁失败会被阻塞但依旧有抢占锁的机会, 因此阻塞的线程需要使用 queue[CLH 的变种实现] 进行排队管理
   - 如果共享资源被占用了, 就需要一定的知识唤醒机制来保证锁的分配
   - 通过自旋, CAS, LockSupport 等方式维护 state 的变量状态

3. 综述

   - AQS 使用一个 volatile 的 int 类型的的成员变量表示同步状态,
   - 通过内置的 FIFO 队列完成资源的排队工作, 将每一条要去抢占的资源的线程封装成一个 Node 节点来实现锁的分配, 通过 CAS 完成对 state 的修改

4. line - framework

   ![avatar](/static/image/java/javase-juc-aqs-framework.png)

   ![avatar](/static/image/java/javase-juc-aqs-layout.png)

   - state: 0 表示未被占用, 1 表示已被占用, > 1 表示重入锁
   - 内部是 CLH 的双向队列 Node[内部是有 Thread 线程(表示占有锁的线程)]: `自旋`

   - code

   ```java
   public abstract class AbstractQueuedSynchronizer {
     private transient volatile Node head;
     private transient volatile Node tail;
     // 表示锁是否空闲
     private volatile int state;

     static final class Node {
       volatile Node next;
       volatile Node prev;

       // 以共享方式等待锁
       static final Node SHARED = new Node();
       // 以排他方式等待锁
       static final Node EXCLUSIVE = null;

       // 每一个等待线程的状态
       // 1. CANCELLED =  1: 线程获取锁的请求已经取消
       // 2. SIGNAL    = -1: 线程程序已经准备好, 就等资源释放了
       // 3. CONDITION = -2: 在队列中, 等待被唤醒
       // 4. PROPAGATE = -3: 当线程处于 SHARED 模式下才会使用
       volatile int waitStatus = 0;

       // 当前占用锁的线程
       volatile Thread thread;
     }
   }
   ```

5. ReentrantLock

   - Lock 接口的实现类一般都是通过聚合一个 `队列同步器` 的子类完成访问控制的
   - code layout

     ```java
     public class ReentrantLock implements Lock, java.io.Serializable {

       public ReentrantLock(boolean fair) {
           sync = fair ? new FairSync() : new NonfairSync();
       }

       private final Sync sync;
       abstract static class Sync extends AbstractQueuedSynchronizer {
       }

        static final class FairSync extends Sync {
          final void lock() {}
          protected final boolean tryAcquire(int acquires)  {}
        }

        static final class NonfairSync extends Sync {
          final void lock(){}
            protected final boolean tryAcquire(int acquires) {}
        }
     }
     ```
