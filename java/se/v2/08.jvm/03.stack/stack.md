## Program Counter Register

1. 一个指向下一个执行方法的指针
2. 内存使用少
3. native 方法的 PC Register 是 null

## stack

![avatar](/static/image/java/javase-jvm-stack.png)

1. 设计初衷

   - 由于跨平台性的设计, Java 指令都是基于栈[8 位对齐]来设计的: 不同平台的 CPU 架构不同, 所以不能设计为基于寄存器的[16 位为对齐]
   - 基于栈的优势: 跨平台, 指令集小, 编译器容易实现
   - 劣势: 性能下降, 实现的同样的功能指令多
   - 栈顶缓存:
     1. 原因: 完成同一操作要更多的字节码指令, 意味更多的 IO, 由于操作数是存储在内存中的, 因此频繁地执行内存读/写操作必然会影响执行速度;
     2. Hotspot JVM 将栈顶元素全部缓存在物理 CPU 的寄存器中, 以此降低对内存的读/写次数, 提升执行引擎的执行效率

2. 简介:

   - 管理 Java 程序的运行, 保存方法的局部变量, 部分结果, 参与方法的调用和返回
   - 生命周期与线程的生命周期相同
   - 访问速度仅次于 PC 计数器[只涉及到入栈和出栈的操作]
   - 不存在垃圾回收问题: StackOverflow[深度/-Xss]
   - 线程私有

3. 存储: 方法栈帧[一个栈帧对应一个 Java 方法的调用]

   - [istore/iload]局部变量表: 是一个数字数组, 主要用于存储方法**参数**和定义在方法体内的**局部变量**

     1. 数据类型包括: 基本数据类型, 引用类型, 返回值类型[returnAddress 指向字节码指令的地址]
     2. 线程私有数据, 不存在线程安全问题
     3. 局部变量表的容量大小在编译期间被确定, 在方法运行期间不会改变[数组]
     4. 槽 Slot:
        - 这些数据类型在局部变量表中的存储空间用局部**变量槽 Slot**来表示
        - long 和 double 是 64 位占两个槽, 其余占一个
        - 所以局部变量表的容量就是槽的个数，在编译期间就是确定的

   - [iconst]操作数栈: 保存计算的中间结果, 计算过程中变量临时的存储空间
   - 帧数据区

     1. 动态链接[指向运行时常量池的方法引用]: 为了将符号引用[常量池中的一个字符串]转换为直接引用[指向方法的真正的入口]的
        - 动态链接指向的是方法区的运行时常量池 & 解析指向的是 class 文件中的常量池
        - 动态链接是在字节码解释执行时 & 解析是在类加载时
     2. 方法返回值: Java 方法有两种返回函数的方式: 不管使用哪种方式, 都会导致栈帧被弹出
        - 一种是正常的函数返回，使用 return 指令；
        - 另外一种是抛出异常
     3. 附加信息

4. 栈管运行, 堆管存储
5. 不发生 GC, 线程私有

6. relation in stack heap and method area

   ![avatar](/static/image/java/stack-heap-MA.png)

7. PermGen 负责加载 `rt.jar: JDK Class, Interface etc.`; 只有 jvm 销毁时才会释放这些资源

## native stack

1. 本地方法栈是线程私有的
