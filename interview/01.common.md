## [接口幂等性](https://github.com/Alice52/java-ocean/issues/201)

1. 定义: 就是任意多次执行所产生的影响均与一次执行的影响相同
2. 场景

   - Feign 的 retry 机制
   - 用户多次点击
   - 重复提交[连续点了 2 次/web 端回退导致的]
   - 有一些操作用户退出了, 又重新点击进来: 放大了时间差

3. 操作本身具有幂等性

   - 带主键的插入,
   - 查询
   - 定量更新
   - 删除操作

4. 操作不具有幂等性的: 参数不同且指定时间内多次提交

   - POST 增量修改[减库存]: 基于现在的数据库数据更新

5. 解决方案

   1. token 机制: 验证码
      - 先删除令牌 + `redisget&del` 是原子性的
   2. 数据库锁: 悲观锁[for update] + 乐观锁[version]
   3. 数据库唯一性约束: 微服务间可以提供唯一 Id 进行判别[req-id 或者业务 id]
   4. 业务幂等

   ```sql
   -- 比如订单系统, 其中的扣款操作的幂等性设计:
   -- 可以通过设置 paystatus & orderId 来做幂等性
   -- 如果同一个订单的调用两次扣款操作, 第一次扣款成功之后则 paystatus 修改为 paid, 第二次执行以下 sql 则没有影响

   -- update userAmount set amount = amount - 'value', paystatus = 'paid' where orderId= 'orderid' and paystatus = 'unpay'
   ```

6. practice: 指定时间内同一个人的同样请求的参数出现大于 1 次就会触发幂等

   - local: `<uri, <md5, count>>` count is stored in ConcurrentHashMap
   - redis: setnxex, key-md5, value-uri=token

## 分布式唯一 Id

- 作为数据基础所以一定要`高可用`, `高并发`

### ~~UUID~~

1. 太长, 占用空间太大
2. 不是自增的, 作为数据库主键会出现`也分裂问题`

### 数据库自增

1. 在分表时会出问题, 两张表各自自增, 就会重复的 Id
2. 因此可以使用另外一张表去获取自增的 Id 使用

   ```sql
    create table seq_no(
        id bigint(20) unsigned not null auto_increment,
        stub char(10) not null default '',
        primary key (id)
    ) engine=InnoDB;
    -- necessary
    create unique index IDX_STUB on seq_no(stub)

    replace into seq_no(stub) value('anyword');
    select * from seq_no
    select last_insert_id();
   ```

3. `2 的问题`: 高可用下所有的数据库都应该是高可用的

   - 主从同步的延迟问题: 因此可能会出现同步丢失导致的重复问题
   - 主主模式下: 可以通过修改主键起始值和步长控制[使得每台 server 产生的 Id 不同]; 扩容时很难修改`[可以在上层加一个 service 去获取 Id]`

4. 缺点: 每次获取一个 Id 需要访问一次数据库

### 号段模式

1. 基于`数据库自增` 的且是一次获取一批 id[维护在内存中(有一个上层 DistributIdService)]
2. sql

   ```sql
   CREATE TABLE id_generator (
       id int(10) NOT NULL,
       current_max_id bigint(20) NOT NULL COMMENT '当前最大id',
       increment_step int(10) NOT NULL COMMENT '号段的长度',
       PRIMARY KEY (`id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
   ```

3. DistributIdService 是集群的, 数据库连接的是同一个数据库, 可能出现多个实例同时请求号段

   ```sql
   -- newMaxId是DistributIdService中根据oldMaxId+号段的长度算出来的; failed 之后则先获取一下 current_max_id 再计算 newMaxId
   update id_generator set current_max_id=#{newMaxId}, version=version+1 where version = #{version}
   ```

4. 数据库可以是多主模式: 通过 id 初始值和自增步长控制每台 server 返回的 Id 都不一样

### 雪花 ID

![avatar](/static/image/common/uuid-snow.png)

1. 让负责生成分布式 ID 的每台机器在每毫秒内生成不一样的 ID 就行了
2. 结构

   - 64 bit 的正整数: long 类型
   - 1bit: 固定为 0, 二进制中最高位为符号位, 0 为整数, 1 位负数.所以固定为 0 表示生成的 ID 都为正数
   - 41bit: 作为毫秒数, 大约能用 69`(1L << 41) / (1000L * 60 * 60 * 24 * 365)` 年; 存储的是时间戳的差值`当前时间-固定的开始时间`
   - 10bit: **作为机器编号**` [5bit 是数据中心 ID, 5bit 为机器 ID``很难实践 `]. 支持 1204 个实例.
   - 12bit: 序列号, 一毫秒最多生成 2^12=4096 个.

3. 优点: 递增, 且按时间有序. 性能高, 可根据情况分配 bit
4. 缺点:
   - 依赖机器时钟: 机器时钟回拨时可能出现重复 ID
   - 机器 Id[worker] 在集群模式下很难实践

### 百度[uid-generator](https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md)

![avatar](/static/image/common/uuid-baidu.png)

1. uid-generator 使用的就是 snowflake, 只是在生产机器 id, 也叫做 workId 时有所不同
2. 结构

   - 64 bit 的正整数: long 类型
   - 1bit: 固定为 0 表示生成的 ID 都为正数
   - 28bit: 存储的是时间秒数的差值`当前时间-固定的开始时间`: 时间基点"2016-05-20"的增量值[8.7]
   - 22bit: workId, `同一个应用每重启一次就会消费一个workId`
   - 13bit: 序列号, 一毫秒最多生成 2^13=8192 个.

3. workId 的生成
   - 默认提供的策略: 应用启动时由数据库分配
   - 应用在启动时会往数据库表(uid-generator 需要新增一个 WORKER_NODE 表)中去插入一条数据, 数据插入成功后返回的该数据对应的自增唯一 id 就是该机器的 workId, 而数据由 host, port 组成

### 美团[Leaf]

1. snowflake 的一种 + 支持号段模式
2. workId 的生成
   - Leaf 中 workId 是基于 ZooKeeper 的顺序 Id 来生成的
   - 在启动时都会都在 Zookeeper 中生成一个顺序 Id, 相当于一台机器对应一个顺序节点, 也就是一个 workId

### Redis

1. 使用 incr, 但是需要考虑持久化的问题导致的 id 重复
