## HTTP

### 1. ISO 7 模型

```js
应用层: http / ftp / smpt;
表示层;
会话层[加密];
传输层: tcp;

网络层: ip;

数据链路层: 以太网头部;
物理层;
```

1. HTTP/1.0 是短连接: HEAD, GET, POST 方法
2. HTTP/1.1 是长连接: HEAD, GET, POST, PUT, DELETE, OPTIONS, TRACE 和 CONNECT

   ```js
   HTTP/1.1 200 OK
   // 表示服务器端发送长度, 客户端在接收到这么多数据后就会处理相应的逻辑, 否则就一直在接收
   Content-Length: 4

   zack
   ```

### 2. POST/GET

1. 本质上都是 TCP 链接, 由于 HTTP 的规定和浏览器/服务器的限制, 导致他们在应用过程中体现出一些不同
2. 区别:
   - [1]浏览器回退 GET 请求是无害的, POST 会出现请求重复提交问题
   - [4]`GET 在 URL 中传送的参数且有长度限制[不安全], 且只能 URL 编码`, 而 `POST 是放在 Body, 支持多种编码方式`
   - [2]GET [返回值/参数]可以被缓存, POST 不可以[除非手动设置]
3. GET 请求也可以有 Body; POST 也可以有 Paramter: `只是不太常规`
   - 虽然 GET 可以带 request body, `却不能保证一定能被接收到`
4. URL 长度问题: 业界不成文的规定是, [大多数]浏览器通常都会限制 url 长度在 2K 个字节, 而[大多数]服务器最多处理 64K 大小的 url
5. **GET 请求参数传递可以通过任何方式, 只要 server 能解析就可以: `默认时 ？ &` + token 在 header 中**
6. 安全: POST 比 GET 方法存在编码上的相对安全, 但是 HTTP 是明文传输的[都不太安全], 推荐使用 `HTTPS`
7. 数据包
   - GET 是一个数据包: 浏览器会把 http header 和 data 一并发送出去，服务器响应 200[返回数据]
   - POST 是两个数据包: 浏览器先发送 header, 服务器响应 100 continue, 浏览器再发送 data, 服务器响应 200 OK[返回数据]
   - 因为 POST 需要两步, `理论上`时间上消耗的要多一点, `看起来`GET 比 POST 更有效: `但并不是的有坑`
     - 各自语义不能混用
     - **网络环境好时一次两次发包没有区别, 网络差时两次包的 TCP 在检验数据包完整性上有很大的优势**
     - Firefox、Chrome POST 也是一次包

### 3. http0.9/Http1.0/Http1.1/http2

1. 0.9-1.0

   - 更多的格式
   - 增加 POST 和 HEAD 方法
   - 增加请求头
   - 响应数据多样化
   - 增加状态码

2. 1.0-1.1

   - keep-live 特性, 长连接
   - 更强大的缓存机制
   - 更多的错误处理和出错误码
   - 增加 HOST 头
   - 对带宽加大优化, pipelining

3. 1.1-2

   - 传输数据流大量减少
     1. 二进制传输 + 分帧
     2. 标头压缩: 压缩 header
   - 多路复用: 双向的并行的传输多个请求
     1. 消息优先级
     2. 一个 TCP 连接可以有多个 stream{双向},
     3. 每个 stream 可以包含多个 message,
     4. 一个 message 可以包含多个 frame[最小单位/二进制]
   - 服务器消息推送
     1. 并行推送
   - 基于 https 的加密传输
   - 支持明文 http
   - spdy

4. http 长连接
   - 减少握手次数
   - 减少并发连接数减少服务器资源的消耗
   - 降低 TCP 拥塞控制的影响

## 三次握手

1. 流程

   ![avatar](/static/image/common/http/http-connet.png)

2. SYN 攻击

   - 攻击者短时间伪造不同 IP 地址的 SYN 报文, 会快速占满 backlog 队列, 使服务器不能为正常用户服务
   - net.core.netdev_max_backlogL: 接收自网卡, 但是未被内核协议栈处理的报文队列长度
   - net.ipv4.tcp_max_syn_backlog: SYN_RCVD 状态连接的最大个数
   - net.ipv4.tcp_abort_on_overflow: 超出处理能力时, 对新的 SYN 直接回包 RST, 然后丢弃连接

3. tcp fast open: 第一次握手之后会携带 cookie, 下次直接携带 cookie 发送[server 会校验]
4. 拥塞窗口慢启动

## 四次挥手

1. time_wait 是 2 MSL (报文最大生存时间)
   ![avatar](/static/image/common/http/http-timewait.png)
   - tcp.ipv4.tcp_tw_resue = 1 可以优化 time_wait 时间长的问题
