## 1. 什么时 aop

1. 在我们的传统的面向对象的日常开发中, 我们的业务逻辑时自上而下的;
2. 在这些自上而下的过程中会产生一些公用的逻辑[横切性问题], 这些问题不会影响具体的业务实现{主流程}, 但是每个业务都自己实现的花, 就会分散到代码的各个部分, 难以维护或修改
3. aop 就是处理这些横切性问题的, 将他们与主业务逻辑分开, 到达解耦的木器, 增加代码的重用性和可维护性, 提高开发效率
4. 比如日志, validate, tx, 效率检查, _异常处理_
5. 相关术语

   - 横切关注点: 从每个方法中抽取出来的同一类非核心业务
   - 切面(Aspect): 封装横切关注点信息的类, 每个关注点体现为一个通知方法
   - 通知(Advice): 切面必须要完成的各个具体工作 & 顺序
   - 目标(Target): 被通知的对象
   - 代理(Proxy): 向目标对象应用通知之后创建的代理对象
   - 连接点(Joinpoint): 横切关注点在程序代码中的具体体现, 对应程序执行的某个特定位置
   - 切入点(pointcut): 一些 Joinpoint 的集合

   ![avatar](/static/image/spring/spring-aop.png)

6. aop 在 spring 中体现为 spring aop 或 aspectj: jdk/cglib 的实现
   - spring aop 只是使用了 aspectj 的语法风格
   - 如果是接口会默认使用 jdk Proxy: Xxx$Proxy extends Proxy implement Xxx
   - 如果是实现类则默认会使用 cglib: Xxx extends XxxImpl implement Xxx
7. spring aop 的执行顺序 4/5 的区别
8. JoinPoint 的定义
   - **@annotation**
   - exceution
   - this/@this
   - target/@target
   - arg/@arg

## 2. 环绕通知 ProceedingJoinPoint 和 JoinPoint 的区别是什么

1. ProceedingJoinPoint extends JoinPoint
2. JoinPoint 只能获取相关参数, 无法执行连接点
3. ProceedingJoinPoint 可以执行 procced 方法, 执行连接点

## ~~3. aop 与 ioc 的关系~~

1. ioc 和 aop[aspectj 也可以] 的概念都是可以独立与 spring 的
2. aop 的所有对象都需要在 ioc 容器中
