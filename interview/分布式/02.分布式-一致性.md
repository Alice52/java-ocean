## [简述 paxos 算法](https://www.bilibili.com/video/BV1kA411G7cK)

1. 简介:

   - **一个分布式系统如何就某个值达成一致**
   - 分布式数据系统的初始值相等且执行相等的操作系列, 最后也是一致的
   - 前提: 通信可靠不会被篡改
   - 是理论指导, 不是解决方案, 不能直接使用, 但是 raft, zab 等具体的落地方案

2. 角色介绍: `一个进程可以充当不同的角色`

   - proposer: 向集群提出议案 + 在发生冲突时调节
   - acceptor: 对提议者进行投票, 只有达到大多数时才会被最终接受
   - learner: 提议接受者, 单纯记录人员, acceptor 告诉那个 value 被共识了他就记录一下, 并给其他未共识的节点广播
   - proposal: proposer 提出的议案或者建议[编号为 n 和内容 value]
   - 最终的目标: 每个 proposer， acceptor, learner 都认为同一个 proposal 中的值被选中

3. 分类

   - basic paxos: 一轮只能确定一个值
   - multi-paxos: 一轮只能确定多个值
   - fast-paxos: zookeeper

4. 缺点
   - 活锁: prepare 可以成功, 但是 accept 时一直可能失败
     1. proposer 的 proposal 被拒绝之后, 会采纳 acceptor 的更大编号进行提交
     2. 如果 两个 proposer 都发现自己自己编号低转而提出更大的 n 就会导致死循环
     3. 解决: 二进制指数退避算法[时间等待]
   - 效率低下: 完整流程需要两大轮返回请求 + `multi-paxos 先选举出leader之后每次就只需要一轮`
   - 实现困难: 共识算法的公有问题

### basic paxos

1. prepare 阶段
   - prepare(n) 请求:
     1. proposer[在收到客户端请求或者发现本地有未提交的值{宕机}] 则提出一个编号为 n(自己已知递增) 的议案
     2. 向超过半数的/所有的 acceptor 广播, `只有编号`
   - **promise(n, value) 返回: acceptor 收到一个编号为 n 的 prepare 请求** 这里还是优点问题的: `有承若的请求 --> 已承若请求和N比 --> 是否有已提交的方案`
     1. 如果 acceptor 已经有已提交的 value 记录, 对比记录的编号和 N, 大于 N 则拒绝回应， 此否则返回该记录的 value 即编号
     2. 如果 acceptor 已经没已提交的 value 记录, 判断本地是否有编号 N1, 如果 N1 > N 则拒绝回应, 否则将 N1 改为 N 后并响应 prepare
2. accept 阶段

   - accept(n, value) 请求: proposer 收到多数派[多余一半的 acceptor 返回的 promise]
     1. 如果所有的 promise 返回的都是 N 则使用 N 对应的值作为 value, 否则会使用返回中最大编号对应的值作为 value
     2. proposer 会给半数以上的 acceptor 发送一个 accept(n, value`)的请求
     3. acceptor 对比 N 和自己承若的请求, 大于 N 则拒绝响应; 否则接受提案+广播 accept(n, value)
   - 当 proposer 收到超过半数的 acceptor 的返回值之后, 达成共识, 采用 N 编号对应的值
   - 并且同步给 learner 使未响应的 acceptor 达成一致

   ![avatar](/static/image/common/mic-paxos-flow-v2.png)
   ![avatar](/static/image/common/mic-paxos.png)

### multi-paxos

1. proposer-A 的 accept(n, value) 成功之后, 则让其他节点在一段时间内不能 accept 请求
2. 这样的话后面 proposer-A 就可以不需要经过 prepare 确认, 直接 accept: `重复使用该编号进行值修改{相当于时一个 leader}`
3. 直到某一个 accept 请求因超时而失败, 则会重新发起 prepare 进行 leader 的选举[accept 成功]
