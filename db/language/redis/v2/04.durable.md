### durable: 默认开启 RDB[断电丢数据问题]

1. 持久化

   - AOF: 指令级别的, 设置多久改动一次就执行一次 aof; redis 重启时数据恢复很慢[数据量大的话]
     - aof 文件重写: 将多次操作 key 的指令把柄成一个[为了恢复数据嘛]
   - RDB: 数据级别的, 快照, 设置多久改动一次就执行一次快照, 会丢数据, 数据恢复快
   - 同时打开 AOF 和 RDB, 但是没有打开 混合持久化 时重启会使用 AOF 策略
   - 混合持久化: 需要保证 aof 和 rdb 都打开

     ```js
     aof-use-rdb-preamble no
     ```

     - bgrewriteaof: 会将 此时的 rdb 文件写入 aof[为了快速重启], 重写期间的新命令会在内存中, 直到重写结束后才会 以 aof 文件的方式写入 aof 文件

#### RDB: 会丢数据, 但是恢复快[只在 Slave 上持久化 RDB 文件]

1. rdb 存盘的是某一时刻的数据:

   - ~~单线程阻塞不对外提供服务~~
   - linux 的父子进程, 常规上是数据隔离的

     ```shell
     echo $$ | more # 输出父进程ID, 原因是 $$ 优先级高于 |
     echo $BASHPID | more # 输出子进程ID

     num=1
     echo $num       # 1
     /bin/bash       # 开启子进程
     echo $num       # --, 此时可以 export num 就可以看见了
     exit
     echo $num       # 1

     # export 的变量 子进程修改对父进程不可见
     # export 的变量 父进程修改对子进程不可见
     ```

   - 创建子进程的问题: fork
     1. 速度
     2. 内存空间问题

2. 相关命令: `save/bgsave`

   - 目录配置
     1. 默认是 rdb 文件名为 dump.rdb
     2. dir
     3. dbfilename
     4. 存储的文件: dbfilename + dir
   - 触发快照: 一个执行完后一个才能执行, 顺讯写
     1. 手动触发 save <seconds> <change>: 阻塞{比如关机维护}
     2. 手动触发 bgsave(fork): 非阻塞
     3. 配置文件中 save: 其实触发的是 bgsave
     4. `save ""` 标识禁用 rdb
     5. flushall 也会产生 dump.rdb 文件, 但是内容 null

3. 概念

   - 在指定时间隔内将内存中的数据集快照写入磁盘, 恢复时直接将快照文件读到内存
   - redis 会单独创建[fork]一个子线程来进行持久化, 先将数据写到一个临时文件中, 带到持久化结束后替换场次的持久化文件
   - 父进程继续接收并处理客户端发来的命令, 而子进程开始将内存中的数据写入硬盘中的临时文件
   - 持久化过程, 主线程不进行任何 IO[fork 结束之后就可以对外提供服务, 其他的 IO 操作由子进程进行]

4. fork[指针+cow]: 速度快, 占用空间小

   - 复制一个与当前进程完全一样的进程[**变量, 环境变量, 程序计数器**]等, 并且作为原进程的子进程`[会造成间断性的暂停服务] + master 不要有rdb操作`
   - fork 进程时 redis 是不对外提供服务的
   - 在执行 fork 的时候操作系统[Unix]会使用写时复制[copy-on-write]策略, 即**fork 函数发生的一刻父子进程共享同一内存数据**, 当父进程要更改其中某片数据时[如执行一个写命令], 操作系统会将该片数据复制一份在修改以保证子进程的数据不受影响, 所以新的 RDB 文件存储的是执行 fork 一刻的内存数据
   - 为此需要确保 Linux 系统允许应用程序申请超过可用内存[物理内存和交换分区]的空间, 方法是在/etc/sysctl.conf 文件加入 vm.overcommit_memory = 1, 然后重启系统或者执行 sysctl vm.overcommit_memory=1 确保设置生效
   - RDB 文件是经过压缩[可以配置 rdbcompression 参数以禁用压缩节省 CPU 占用]的二进制格式, 所以占用的空间会小于内存中的数据大小, 更加利于传输

5. feature

   - 优点: 适合大规模的数据恢复
   - 缺点: 只有一个 rdb 文件, 要是坏了就糟了
   - 缺点: 对数据的完整性要求不高, 丢数据可能性大一点
   - ~~fork 时需要 2 倍的内存~~: 这个是错误的
   - bgsave/save 会触发 IO 操作, 所以也不会让一个 redis 的内存过于大

6. 执行时机

   - 手动执行 bgsave
   - 手动执行 save
   - 自动执行 save
   - 从节点连接到主节点发送 sync 命令, master 会执行 bgsave
   - shutdown/flushall

7. conclusion

   ![avatar](/static/image/db/redis-rdb.png)

#### AOF

1. 概念: **全量**

   - 以日志的形式来记录每个`写操作`, 重启时从头到尾执行一遍
   - aof 文件很大的话会很慢

2. 存储的文件
   - 开启: appendonly yes/no
   - 文件名称: appendfilename
3. aof 文件恢复

   - 备份被写坏的 aof 文件
   - redis-check-aof --fix
   - restart

4. rewrite

   - bgrewriteaof: 会将 此时的 rdb 文件写入 aof[为了快速重启], 重写期间的新命令会在内存中, 直到重写结束后才会 以 aof 文件的方式写入 aof 文件
   - redis 会当 aof 文件大于 64M 且 size{重写后的 size} 翻倍时重写
   - 4.0 之前会 fork 出一个新的进程将文件重写[先写入临时文件]: ~~是删除抵消的命令 + 合并重复的命令~~
   - 4.0 之后会 rbd + aof

5. 触发 aof: 调用 flush 进行刷盘

   - appendfsync always: 性能差一些
   - appendfsync everysec: 异步每秒一个, 如果一秒内当即会有数据丢失, buffer 满了会自动刷盘, 所以最多丢一个 buffer
   - appendfsync no: ~~不同步~~, 这个是交给系统决定, 不是不同步, 可能会丢失一个 buffer 大小的数据

6. feature

   - 数据丢失概率小
   - 如果同时开启了 RDB 和 AOF, 数据恢复时只会使用 AOF
   - aof 文件大于 rdb 时重启恢复慢: bgrewriteaof
   - no 时效率与 rdb 相同
   - flushall 发生之后且没有发生 rewriteaof 数据是可以恢复的

7. conclusion

   ![avatar](/static/image/db/redis-aof.png)

#### 混合持久化{4.0}: RDB 的快 + AOF 的全量

1. 需要保证 aof 和 rdb 都打开

   ![avatar](/static/image/db/redis-durable.png)

   ```js
   aof-use-rdb-preamble no
   ```
