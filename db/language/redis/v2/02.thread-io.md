## thread

1. redis 线程问题: **单线程[工作线程=输入计算输出]**

   - 运算都是内存级别的运算与存储:

     1. 比机械硬盘快 10w 倍, 比固态[IO 速度]快 1k 倍; 如果命中 cache Line 会更快
        ![avatar](https://user-images.githubusercontent.com/42330329/169217604-3034cca1-b6ca-4f76-b95c-8843e9f2782a.png)

   - 单线程, 不需要线程切换和竞争条件, 不需要考虑并发锁问题
   - 非阻塞 IO - IO[网络 I/O] 多路[多个 TCP 连接]复用[共用一个线程或进程]:
     1. redis 利用 epoll 来实现 IO 多路复用
     2. 将连接信息和事件放到队列中, 依次放到文件事件分派器
     3. 事件分派器将事件分发给事件处理器

   ![avatar](/static/image/db/rredisthread.png)
   ![avatar](https://user-images.githubusercontent.com/42330329/169217763-b8e8bccd-f1d2-4a03-a0e0-dc369a23e70f.png)

   - 合理的数据结构
   - 数据编码: 根据字符串的长度及元素的个数适配不同的编码格式

2. 线程安全问题

   - 计算线程是串行的单线程: 安全
   - 但是使用 redis 时业务上要自行保证顺序: FIFO

3. redis 6.x 使用多线程

   - 核心工作线程还是 1 个
   - 5.x
     ![image](https://user-images.githubusercontent.com/42330329/169222817-6c23d685-5456-4faf-9486-b7e0bc99210f.png)
   - 6.x
     ![image](https://user-images.githubusercontent.com/42330329/169222875-80bfd0a3-e9b2-4d81-902a-7de1791f2139.png)

4. 数据结构
   - [link]()
