## redis guideline

### 键值对使用规范

- 好的 key **命名**: 才能提供可读性强/可维护性高的 key, 便于定位问题和寻找数据
- value 要避免出现 **bigkey**、 选择高效的序列化和压缩、**使用整数对象共享池**、选择高效恰当的**数据类型**

1. key 命名: `「业务名:表名:id」` + `不要包含特殊字符:空格、换行、单双引号以及其他转义字符`
2. key 不能太长: 适当缩写
   - key 也是 sds 对象, 长了也会占用空间[多的话]
3. 不要使用 bigkey: value / size
4. 使用整数对象共享池
   - Redis 内部维护了 0 到 9999 这 1 万个整数对象, 并把这些整数作为一个共享池使用
   - 因此即使大量键值对保存了 0 到 9999 范围内的整数, 在 Redis 实例中, 其实只保存了一份整数对象: 可以节省内存空间
   - 失效的情况:
     1. maxmemory 使用 lru{allkeys-lru / volatile-lru}: 因为 lru 需要统计每个键值对的使用时间, 共用的话就没法统计了
     2. 集合类型数据采用 ziplist 编码, 且集合元素是整数: ziplist 是紧凑的内存结构, 判断整数对象的共享情况效率低

### 命令使用规范

- 涉及大量操作、耗时长的命令, 就会严重阻塞主线程
- 可以使用 rename-command 命令在配置文件中对这些命令进行重命名: 让客户端无法使用这些命令

1. KEYS: 该命令需要对 Redis 的全局哈希表进行全表扫描, 严重阻塞 Redis 主线程
   - SCAN + lua: 可以做到*全表*扫描
2. FLUSHALL: 删除 Redis 实例上的所有数据, 如果数据量很大, 会严重阻塞 Redis 主线程
   - 加上 ASYNC 选项: 异步执行
3. FLUSHDB: 删除当前数据库中的数据, 如果数据量很大, 同样会阻塞 Redis 主线程
   - 加上 ASYNC 选项: 异步执行
4. MONITOR

   - 把监控到的内容持续写入输出缓冲区
   - 如果线上命令的操作很多, 输出缓冲区很快就会溢出了, 这就会对 Redis 性能造成影响, 甚至引起服务崩溃
   - **所以除非十分需要监测某些命令的执行才使用: 如 Redis 性能突然变慢, 要查看下客户端执行了哪些命令**

5. 慎用全量操作命令

   - HASH: hgetall ==> HSCAN
   - List: lrange ==> 拆分存储
   - Set: smembers/zrange/sinter/sdiff ==> SSCAN

6. 禁止批量的给 keys 设置相同的过期时间
7. 多使用批量操作提高效率
8. 尽量使用 Pipeline 批量操作数据
9. 注意客户端的连接使用问题
10. 不建议使用 Redis 事务功能
11. 集群下的 pipeline & lua: 要保证所有的 key 在一个 server slot 上
12. 高并发下建议客户端添加熔断功能(例如 netflix hystrix)

### 数据保存规范

1. 冷热数据分离

   - redis 只存放热点高频的小值: redis 核心是抗并发的

2. 业务数据隔离: 不要将不相关的数据业务都放到一个 Redis 中

   - 一方面避免业务相互影响
   - 另一方面避免单实例膨胀, 并能在故障时降低影响面, 快速恢复

3. 设置过期时间: 内存是昂贵资源

   - 否则长时间使用会 oom, 导致服务崩溃

4. 控制单实例的内存容量: `2~6 GB`

   - RDB 快照: fork
   - 主从集群进行数据同步

5. 防止缓存雪崩/击穿/穿透

### 运维规范

1. 使用 Cluster 集群或者哨兵集群: 做到高可用
2. 实例设置最大连接数: 防止过多客户端连接导致实例负载过高, 影响性能
3. 不开启 AOF 或开启 AOF 配置为每秒刷盘: 避免磁盘 IO 拖慢 Redis 性能
4. 设置合理的 repl-backlog: 降低主从全量同步的概率
5. 设置合理的 slave client-output-buffer-limit: 避免主从复制中断情况发生
6. 根据实际场景设置合适的内存淘汰策略
7. 使用连接池操作 Redis
