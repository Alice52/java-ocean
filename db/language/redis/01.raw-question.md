## redis

### 1.redis 的数据结构和使用场景

1. string: 计数[喜欢的文章数量/点赞数/临时存储位], 分布式锁[原子操作]
2. ~~hash: 存储大对象[少量属性变化], 购物车, 一般对象用 string + json 存储,对象中某些频繁变化的属性抽出来用 hash 存储~~

   ```java
   Map<string, Map<K, V>>
   // 1. hset     shopcart:uid productid count  新增商品
   //    hget     shopcart:uid productid
   // 2. hincrby  shopcart:uid productid count  商品 +1
   // 3. hdel     shopcart:uid productid        删除商品
   // 4. hlen     shopcart:uid                  商品总数
   // 5. hgetall  shopcart:uid                  所有商品
   ```

3. ~~list: 公众号列表[别人发布文章就会 push 进我的 list]~~
   - 实现栈: LPUSH + LPOP
   - 实现队列: LPUSH + RPOP
   - BlockingQueue: BLPUSH + BRPOP
4. set: **抽奖[SRANDMEMBER/SPOP]**/微信的点赞[可见性 sinter]/推荐可能认识的人[sdiff]/社交的共同关注[sinter]
5. zset: 排行榜[不停的被刷新], 热搜
6. bit: 签到 [SETBIT key offset(512m) value/getbit, bitcount]

   - 一个以每天日期为 key, 每个 uid 为偏移量
   - 一个以用户 uid 为 key, 当天在一年中的索引为偏移量，

7. 类型相关的命令

   ```shell
   set age 12
   set name zack
   type age # string
   type name # string
   object encoding age # int
   object encoding name # embStr
   ```

### 2.redis 快的原因

1. 内存级别的存取
2. 单线程, 不需要线程切换
3. 多路复用 IO + 线程模型

   - I/O ：网络 I/O
   - 多路：多个 TCP 连接
   - 复用：共用一个线程或进程

4. 合理的数据结构
5. 数据编码: 根据字符串的长度及元素的个数适配不同的编码格式

### 12.redis 常见的数据结构

1. sds:
   - sds[有长度], len O(1), 二进制安全
   - 内存重新分配: 空间预分配[len < 1M，会多分配一个 len; len > 1M, 多分配 1m] + 惰性空间释放
2. linkedlist: len + 双向无环链表, 具有 stack 和 queue 的特性
3. hashtable: 2 个 key-链地址法[单向链表], rehash 是渐进式的[服务的高可用]
4. skiplist: 在链表的基础上增加了多级索引来提升查找效率, zset + cluster node, zskiplist[hNode, tNode, len], zskiplistNode[1-32, 分可以相同, 对象不同], 取[分后对象大小]

   - 每一层都有一条有序的链表，最底层的链表包含了所有的元素(O(logN))

5. intset: 不重复的中枢集合
6. ziplist: 压缩空间发明的数据结构, 所有的操作都是通过指针与解码出来的偏移量进行的. 并且压缩列表的内存是连续分配的，遍历的速度很快. 多个 Node[1 个字节数据/1 个整数值]

---

7. 字符串对象 string：int 整数、embstr 编码的简单动态字符串、raw 简单动态字符串
8. 集合对象 set：intset、hashtable
9. 列表对象 list：ziplist、linkedlist
10. 有序集合对象 zset：ziplist、skiplist
11. 哈希对象 hash：ziplist、hashtable

### 3.redis 的持久化

### 4.redis 使用场景

1. 高并发/高性能/高可用
2. 减小 mysql 的压力, 快速的响应[内存界别的操作]
3. 超热的 key 就可以放到 redis 中:

### 5.缓存淘汰策略 6 + 2

1. noeviction
2. volatile-lru
3. **allkeys-lru**
4. volatile-lfu
5. allkeys-lfu
6. volatile-random
7. allkeys-random
8. volatile-ttl
9. LRU 是一种常用的页面置换算法: hash + 双向链表

### 6.常见的命令

### 7.事务: 分布式锁的解锁问题

### 7.常见的配置项

1. 可以通过配置文件配置 & 也可以通过 config 命令行配置
2. aof/rdb: aof-use-rdb-preamble no
3. memory
4. log
5. daeminize: docker
6. protected-mode + requirepass: auth
7. REPLICATION
   - cluster-enabled
   - cluster-config-file
   - cluster-node-timeout

### 8.高可用

1. sm
2. cluster
3. sentinel

### 9.分布式锁

1. 单机版在多线程下需要加锁
2. 微服务: 单机版锁值管自己的 JVM 层面的, 可能会导致 2 个服务买同一个商品
3. 分布式锁的注意点

   - 加锁的原子性: setnxex
   - 解锁的原子性: lua 或者 ~~redis 事务: watch + transaction+ multi+delete + unwatch~~
   - 解锁代码的一定执行 + ex
   - 解决业务超时问题锁续期问题 + 只能删除自己的锁
   - redis 集群时异同同步数据导致的 set 丢失问题: 自己手动修复数据

### 10.生产上 redis 内存陪多大, 怎么修改

1. maxmemory 不配置默认 64bit 使用最大内存
2. maxmemory 参数是字节
3. 查看: info memory / config maxmemory / 配置文件

### 11.redis 内存满了怎么办

1. 满了之后会 set 操作会 OOM
2. key 删除策略: 一个 key 到期了并不是马上就被删除
   - [省内存耗性能]定时删除: 数据过期后马上就被删除, CPU 要时刻计算着过期的 key 压力过大
   - [耗内存省性能]惰性删除: 数据过期不处理, 等到下次使用的时候判断是否过期, 会导致有很多不被访问的 Key
   - 定期删除: 是对上两种的折中, 每隔一段时间执行一次删除, 限制删除操作的时长和频率减少删除操作对 CPU 的影响
     - 周期性轮询, 随机抽取[一部分 key], 利用占比控制删除频率
     - **检测频率时长可以自定义**, 内存压力也不大
     - 还是可能导致一些 key 到期不会被删除
     - 使用前还是需要看是否过期[惰性检查]
3. 缓存淘汰策略:

### 12. 海量数据下怎么快速查找一条记录

1. 使用布隆过滤器, 快速过滤不存在的数据[spring cache 中有笔记]
2. 在 redis 中建立数据缓存

   - 以普通的字符串存储(user-id -> user object) / 以 hash 存储(user-id k->v)`[会存在大量的 key]`
   - 使用一个 hash 存储所有的数据(user-info user-id->uo)`[key 是减少了, 一个 可以存 2^32-1 个键值对]`
   - 存在缓存穿透: 由于布隆过滤器的误判导致的
   - 存在缓存击穿: key 失效导致的, 可以使用锁机制[一个线程写缓存]

3. 查询优化
   - redis 数据是按槽位计算分配存储空间的
   - ~~自己实现槽位计算, 自己计算数据在那台机器上, 然后进行查找~~

### 13.分布式缓存

1. 客户端缓存: 页面/浏览器缓存, APP 缓存, H5 缓存, Localstrage, session-storage
2. CDN 缓存: 内容存储, 数据存储, 内容分发[负载均衡]
3. nginx 缓存: 静态资源
4. 服务器缓存: 本地缓存, 外部缓存
5. 数据库缓存: 持久层缓存[mybatis 缓存], mysql 服务的缓存
6. 操作系统缓存: Page Cahce, Buffer Cache

## redis - project

## redis - redission

1. 使用 redission unlock 的时候需要注意

   ```java
   // IllegalMonitorStateException: attemp to unlock lock, not locked by currentId
   if(lock.isLocked() && lock.isHeldByCurrentThread()) {
     lock.unlock();
   }
   ```

2. redission 的源码 + 看门狗

---

## interview question v2

1. 什么是 redis

   - key-value 的 NoSQL 开源数据库
   - 高性能 + 高扩展 + 高稳定 + 集群
   - 多种数据结构 + 速度快
   - 内存 + 异步持久化 + string max 512m
   - 解决[分布式]缓存 + 锁 + 数据存储 + 解决方案

2. 如果设置了最大使用的内存, 则数据已有记录数达到内存限值后不能继续插入新值
