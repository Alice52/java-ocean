## 1.相关的指令

1. database
2. table: crud
3. view
4. 系统配置参数

## 2.子查询

## 3.事务

1. tx_isolantion
2. InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使⽤的是 **Next-Key Lock**锁算法, 因此可以避免幻读的产⽣,

## 4.存储引擎

1. storage_engine: 不同的存储引擎表示数据在磁盘上不同的组织形式: 查询&存储
2. 整体逻辑结构

   - Connectors: 不同的语言, 连接, 授权认证,安全, 客户端权限, 池化
   - services: interface[接受查询+返回结果] + parser[验证语法+分解 dt+转发] + optimizer[index+优化顺序] + buffer&cache[cache result 表缓存, 记录缓存, key 缓存, 权限缓存[开启查询缓存后在同样的查询条件以及数据情况下, 会直接在缓存中返回结果]]
   - engine: 存储和提取
   - store: 落盘

3. myisam 和 innondb 的区别

   - FK
   - 锁: 表锁行锁
   - 事务
   - 缓存
   - 空间
   - 关注点

## 5.索引

1. crud
2. join 关系图
3. 介绍: 使用在哪里 + 定义[理解] + 文件形式 + InnoDB's B+Tree 好处[IO+sortCPU] + 缺点 + 分类 + 使用场景[4-4] + 建议[8+5]

4. 分类:

   ![avatar](/static/image/db/mysql-index-v2.png)

   - `聚簇索引/非聚簇索引`
     1. 回表
     2. 覆盖索引
   - 单值索引/唯一索引/复合索引[结构]
     1. 索引下推: 5.7
     2. 最左匹配

   ![avatar](/static/image/db/mysql-index-concept.png)

5. innodb 是将索引与数据放在一起的: `innodb 在插入数据时, 数据必须和某个索引列放在一起`
6. 聚簇索引: 数据和索引放在一起的叫聚簇索引
7. 非聚簇索引: 数据和索引不放在一起的叫非聚簇索引, 要查 2 颗 b+树
8. 在不同存储引擎中数据的组织形式也是不同的, myisam 索引与数据是分开放的: 所以 myisam 只有非聚簇索引

## 6.为什么 使用 B+ 树

1. hash 的缺点

   - hash 算法影响比较大, 而且 hash 碰撞可能导致数据不均匀, 可能是链表
   - hash 不支持范围查询: 必须逐个匹配
   - 需要大量的空间

2. AVL/二叉树/红黑树

   - 都是树, 每个节点只有两个节点
   - 导致深度变深[IO 次数变多查询变慢]
   - 局部性原理: 时间局部性和空间局部性, 数据和程序都有聚集成群的倾向, 之前读取过的数据可能会被再次读取的可能性大
   - 磁盘预读: 如果从磁盘中读取 a 字符并不是直接读取 a 字符的; 内存和磁盘进行数据交互的时候有一个最基本的数据单元[页一般 4/8k], 每次读取的时候应该是页大小的整数倍, innodb 默认每次读取 16k 数据

3. B 树

   ![avatar](/static/image/db/mysql-index-b.png)

4. B+ 树:

   ![avatar](/static/image/db/mysql-index-b+.png)

## 7.索引优化建议

1. 单表

![avatar](/static/image/db/mysql-index.png)

2. 多表: 4

   - 尽量不要超过 3 表 join
   - 小表驱动大表
   - on 条件上都要加索引
   - 相关子查询小表在前, 非相关子查询小表在后[in/exist]

3. 避免索引失效[行锁变表锁]: 5+2

   - 尽量每张表不要超过 5 个索引
   - id 自增
   - 全值匹配
   - 最左前缀: 条件顺序
   - **groupby 要和 orderby 一起**
   - or/计算/范围[<>!=like]/null 会失效
   - var 的''

4. order by

   ![avatar](/static/image/db/mysql-order-by.png)

5. group by: `GROUP BY 实质是先排序后进行分组`

## 6.explain 性能分析

1. seq
2. id[大先执行]/~~select_type~~/**type**/possible_keys/key/key_len/ref/Extra[Using filesort]

## 8.慢查询

## 9.锁

1. innodb[可以命中索引的就是行锁] 有表锁和**行锁**: 粒度小, 加锁慢, 开销大, 并发高, 有死锁
2. myisam 只有**表锁**: 粒度大-加锁快-开销小, 并发低无死锁
3. 表锁: 读锁

   - s1 读锁, s1 阻塞该读之外的所有操作
   - s2 没有任何影响

4. 表锁: 写锁

   - s1 写锁, s1 阻塞该写之外的所有操作
   - s2 只会阻塞该表的读写

5. 行锁: 读锁

   - s1 读锁, s1 阻塞该读之外的所有操作
   - s2 无影响

6. 行锁: 写锁

   - s1 写锁, s1 阻塞该写之外的所有操作
   - s2 只会阻塞该记录的读写

7. 建议: 事务范围 + 级别 + narrow 范围 + index-query
8. 分类：

   - Record lock：单个⾏记录上的锁
   - Gap lock：间隙锁, 锁定⼀个范围, 不包括记录本身
   - Next-key lock：record+gap 锁定⼀个范围, 包含记录本身

9. 细节
   - innodb 对于⾏的查询使⽤ next-key lock
   - Next-locking keying 为了解决 Phantom Problem 幻读问题
   - 当查询的索引含有唯⼀属性时, 将 next-key lock 降级为 record key
   - Gap 锁设计的⽬的是为了阻⽌多个事务将记录插⼊到同⼀范围内, ⽽这会导致幻读问题的产⽣
   - 有两种⽅式显式关闭 gap 锁：（除了外键约束和唯⼀性检查外, 其余情况仅使⽤ record lock）
     - 将事务隔离级别设置为 RC
     - 将参数 innodb_locks_unsafe_for_binlog 设置为 1

## 10.数据太多

1. 垂直分区: 指数据表列的拆分, 把⼀张列⽐较多的表拆分为多张表
   - 减少 I/O 次数, 垂直分区可以简化表的结构,易于维护
   - 主键会出现冗余, 引起 Join 操作[在应⽤层进⾏ Join], 让事务变得更加复杂；
2. ⽔平分区: ~~表结构不变, 每⼀⽚数据分散到不同的库中~~ Sharding-JDBC

   - ⽀持⾮常⼤的数据量存储, 应⽤端改造也少, 但 分⽚事务难以解决
   - 跨节点 Join 性能差, 逻辑复杂

## 11.HA

1. sm

## 5.bin-log

## 12.MVCC

1. MVCC 叫做多版本并发控制, 实际上就是保存了数据在某个时间节点的快照
2. MVCC 的原理是查找创建版本⼩于或等于当前事务版本, 删除版本为空或者⼤于当前事务版本,
3. 我们每⾏数实际上隐藏了两列, 创建时间版本号, 过期(删除)时间版本号, 每开始⼀个新的事务, 版本号都会⾃动递增。
4. 为了保证事务读取的数据是在事务开始前就已经存在的, 要么是事务⾃⼰插⼊或者修改的。
