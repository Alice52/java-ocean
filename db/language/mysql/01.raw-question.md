## 1.相关的指令

1. database
2. table: crud
3. view
4. 系统配置参数

## 2.子查询

## 3.事务

1. acid
   - a: undo-log
   - c: 一个事务在执性之前和执行之后，数据库都必须处以一致性状态[如果从 A 账户转账到 B 账户，不可能因为 A 账户扣了钱，而 B 账户没有加钱]
   - i: mvcc
   - d: redo-log
2. tx_isolantion
3. InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使⽤的是 **Next-Key Lock**锁算法, 因此可以避免幻读的产⽣,

4. 读已提交: 读取的是最新一次持久化的版本
5. 可重复读: mvcc 读取的是事务开启之前的版本
6. 事务隔离级别的实现

   - 基于锁的并发控制: 可能导致死锁

     1. 事务根据自己对数据项的操作类型申请对应的锁: 读操作共享锁, 写操作排它锁
     2. 申请锁的请求被发送给锁管理器, 锁管理器针对**当前数据项是否已经有锁**, 以及**申请的和持有的锁是否冲突**决定是否为该请求授予锁
     3. 若授予锁则申请锁的事务继续执行; 若是被拒绝, 则申请锁的事务进行等待, 知道锁被释放

   - 除了使用锁实现并发控制, 还有其他的策略
     1. 基于时间戳的并发控制
     2. 基于有效性检查的控制
     3. 基于快照隔离的并发控制

## 4.存储引擎

1. storage_engine: 不同的存储引擎表示数据在磁盘上不同的组织形式: 查询&存储
2. 整体逻辑结构

   - Connectors: 不同的语言, 连接, 授权认证,安全, 客户端权限, 池化
   - services: interface[接受查询+返回结果] + parser[验证语法+分解 dt+转发] + optimizer[index+优化顺序] + buffer&cache[cache result 表缓存, 记录缓存, key 缓存, 权限缓存[开启查询缓存后在同样的查询条件以及数据情况下, 会直接在缓存中返回结果]]
   - engine: 存储和提取
   - store: 落盘

3. myisam 和 innondb 的区别

   - FK
   - 锁: 表锁行锁
   - 事务
   - 缓存
   - 空间
   - 关注点

## 5.索引

1. crud
2. join 关系图
3. 介绍: 使用在哪里 + 定义[理解] + 文件形式 + InnoDB's B+Tree 好处[IO+sortCPU] + 缺点 + 分类 + 使用场景[4-4] + 建议[8+5]

4. 分类:

   ![avatar](/static/image/db/mysql-index-v2.png)

   - `聚簇索引/非聚簇索引`
     1. 回表
     2. 覆盖索引
   - 单值索引/唯一索引/复合索引[结构]
     1. 索引下推: 5.7
     2. 最左匹配

   ![avatar](/static/image/db/mysql-index-concept.png)

5. innodb 是将索引与数据放在一起的: `innodb 在插入数据时, 数据必须和某个索引列放在一起`
6. 聚簇索引: 数据和索引放在一起的叫聚簇索引
7. 非聚簇索引: 数据和索引不放在一起的叫非聚簇索引, 要查 2 颗 b+树
8. 在不同存储引擎中数据的组织形式也是不同的, myisam 索引与数据是分开放的: 所以 myisam 只有非聚簇索引

## 6.为什么 使用 B+ 树

1. hash 的缺点

   - hash 算法影响比较大, 而且 hash 碰撞可能导致数据不均匀, 可能是链表
   - hash 不支持范围查询: 必须逐个匹配
   - 需要大量的空间

2. AVL/二叉树/红黑树

   - 都是树, 每个节点只有两个节点
   - 导致深度变深[IO 次数变多查询变慢]
   - 局部性原理: 时间局部性和空间局部性, 数据和程序都有聚集成群的倾向, 之前读取过的数据可能会被再次读取的可能性大
   - 磁盘预读: 如果从磁盘中读取 a 字符并不是直接读取 a 字符的; 内存和磁盘进行数据交互的时候有一个最基本的数据单元[页一般 4/8k], 每次读取的时候应该是页大小的整数倍, innodb 默认每次读取 16k 数据

3. B 树

   ![avatar](/static/image/db/mysql-index-b.png)

4. B+ 树:

   ![avatar](/static/image/db/mysql-index-b+.png)

## 7.索引优化建议

1. 单表

![avatar](/static/image/db/mysql-index.png)

2. 多表: 4

   - 尽量不要超过 3 表 join
   - 小表驱动大表
   - on 条件上都要加索引
   - 相关子查询小表在前, 非相关子查询小表在后[in/exist]

3. 避免索引失效[行锁变表锁]: 5+2

   - 尽量每张表不要超过 5 个索引
   - id 自增
   - 全值匹配
   - 最左前缀: 条件顺序
   - **groupby 要和 orderby 一起**
   - or/计算/范围[<>!=like]/null 会失效
   - var 的''

4. order by

   ![avatar](/static/image/db/mysql-order-by.png)

5. group by: `GROUP BY 实质是先排序后进行分组`

## 6.explain 性能分析

1. seq
2. id[大先执行]/~~select_type~~/**type**/possible_keys/key/key_len/ref/Extra[Using filesort]

## 8.慢查询

## 9.锁

1. innodb[可以命中索引的就是行锁] 有表锁和**行锁**: 粒度小, 加锁慢, 开销大, 并发高, 有死锁
2. myisam 只有**表锁**: 粒度大-加锁快-开销小, 并发低无死锁
3. 表锁: 读锁

   - s1 读锁, s1 阻塞该读之外的所有操作
   - s2 没有任何影响

4. 表锁: 写锁

   - s1 写锁, s1 阻塞该写之外的所有操作
   - s2 只会阻塞该表的读写

5. 行锁: 读锁

   - s1 读锁, s1 阻塞该读之外的所有操作
   - s2 无影响

6. 行锁: 写锁

   - s1 写锁, s1 阻塞该写之外的所有操作
   - s2 只会阻塞该记录的读写

7. 建议: 事务范围 + 级别 + narrow 范围 + index-query
8. 分类：

   - Record lock：单个⾏记录上的锁
   - Gap lock：间隙锁, 锁定⼀个范围, 不包括记录本身
   - Next-key lock：record+gap 锁定⼀个范围, 包含记录本身

9. 细节
   - innodb 对于⾏的查询使⽤ next-key lock
   - Next-locking keying 为了解决 Phantom Problem 幻读问题
   - 当查询的索引含有唯⼀属性时, 将 next-key lock 降级为 record key
   - Gap 锁设计的⽬的是为了阻⽌多个事务将记录插⼊到同⼀范围内, ⽽这会导致幻读问题的产⽣
   - 有两种⽅式显式关闭 gap 锁：（除了外键约束和唯⼀性检查外, 其余情况仅使⽤ record lock）
     - 将事务隔离级别设置为 RC
     - 将参数 innodb_locks_unsafe_for_binlog 设置为 1

---

1. 在不同的数据库引擎中是不一样的
2. innodb

   - 共享锁
   - 排它锁
   - 行锁: record lock
   - 间隙锁: gap lock
   - 明建锁: next-key lock
   - 自增锁: id 自增时插入失败也会+1

3. myisam
   - 共享锁
   - 独占锁

## 10.数据太多

1. 垂直分区: 指数据表列的拆分, 把⼀张列⽐较多的表拆分为多张表

- 减少 I/O 次数, 垂直分区可以简化表的结构,易于维护
  - 主键会出现冗余, 引起 Join 操作[在应⽤层进⾏ Join], 让事务变得更加复杂；

2. ⽔平分区: ~~表结构不变, 每⼀⽚数据分散到不同的库中~~ Sharding-JDBC

   - ⽀持⾮常⼤的数据量存储, 应⽤端改造也少, 但 分⽚事务难以解决
   - 跨节点 Join 性能差, 逻辑复杂

## 11.HA

1. sm
   - 修改配置文件 mysqld, relay-log, 要同步的数据库, 开启 bin-log
   - master 对 slave 的用户的授权: `grant replication slave on`
   - change master to master-info[host, port, user, password, log-name, log-position(relay-log.info)]
   - start salve; show slave status\G; stop slave;

## 12.MVCC

1. MVCC 叫做多版本并发控制, 实际上就是保存了数据在某个时间节点的快照
2. MVCC 的原理是**查找创建版本⼩于或等于当前事务版本且删除版本为空或者⼤于当前事务版本,** 但是在更新操作[写操作有锁]时会取最新的数据
3. 我们每⾏数实际上隐藏了两列, 创建时间版本号, 过期(删除)时间版本号, 每开始⼀个新的事务, 版本号都会⾃动递增。
4. 为了保证事务**读取的数据是在事务开始前就已经存在的, 要么是事务⾃⼰插⼊或者修改的。**
5. 流程: **一致性非锁定读**/一致性锁定读
   - A 更新操作未完成的时候 B 想读取, 则在 mvcc 下可以使用 undo-log 读取到 A 事务开始之前的数据

## 13.log

1. [mysql-server]bin-log: 需要自己开启, 并指定模式[语句, row, mixed]
2. [mysql-server]slow-log: 慢查询日志
3. [innodb]undo-log: idb 文件

   - 逻辑日志: 记录的是每一条数据的修改,不是针对数据页[针对的是行记录] 物理日志是修改加载进内存的最小的逻辑单元`页`, 如果记录的是页的修改则是物理日志
   - 实现事务的原子性
   - 用于实现 mvcc:
   - 在任何操作之前, 首先将数据备份到一个地方[undo-log], 然后对事物进行修改, 如果出错或 rollback 则利用 undo-log 中的备份将数据恢复到事务开始之前的状态: `可以近似按以下方法理解`
     1. delete 时则向 undo-log 中插入 insert 一条数据
     2. insert 则在 undo-log 中记录一条 delete 语句
     3. update 则在 undo-log 中记录一条反向的 update 语句

4. [innodb]redo-log: [预写日志]前滚日志, 将来会出现的数据

   - 在事务提交之前不需要将数据持久化到磁盘, 只需要记录到 Redolog 中就行[redo-log 和 bin-log 写完之后就会 commit]
   - 当系统崩溃时, 虽然数据没有持久化到磁盘, 但是 redo-log 已经持久话了, 系统可以根据 redo-log 里的内容将数据恢复到最新的状态
   - innodb_flush_log_at_trx_commit:
     1. 默认值是 1: 表示每此都将数据直接写到 os buffer 并调用 fsync 刷入磁盘
     2. 0: 表示写入 innodb 的 logbuffer, 每秒调用一次 fsync 刷入磁盘
     3. 3: 表示直接写入 OS buffer, 每秒调用 fsync 刷入磁盘
   - redo-log 只能循环写, 不能满了就创建新的

5. relay-log: slave

## reference

1. [可重复读的实现](https://www.cnblogs.com/yuzhuang/p/11585774.html)
