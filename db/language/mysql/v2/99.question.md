## 1. null 对 mysql 性能影响

1. 数据列[索引列]尽量不要有 null[非索引列无所谓], 最好都设置有默认值
   - 存储大量的 null 值, 除了计算更复杂之外, 数据扫描的代价也会更高一些
2. 辅助索引需要 mvcc 多版本读的时候，为什么需要依赖聚集索引
   - 辅助索引中不存储 db_trx_id, 需要依托聚集索引实现 mvcc
3. 索引列允许为 null, 会额外存储更多字节吗
   - 定义列值允许为 null 并不会增加物理存储代价, 但对索引效率的影响要另外考虑
4. 叶子节点总是存储最新数据, 而非叶子节点则不一定
5. avg/sum(null) 统计一个只有 null 值的列 值为 null
6. null=null 的结果是 null; null!=null 的结果也是 null
   - 需要使用 is [not] null
7. is null 是一直会失效的; is not null 在非覆盖索引下会失效, 覆盖索引下不会失效

## 2. mysql 的数据隔离级别从可重复读改为读已提交的影响是什么: 我们项目就是这么改的{阿里云默认级别}

1. 为什么要改?
2. 之前的需要可重复读的场景怎么解决: 比如对账业务
3. 举例说明对高并发秒杀的影响

## 3. insert into 只会锁主键索引树[行锁-与隔离级别无关]

1. 成功加的是行写锁: 本 session 无限制, 其他 session 此时想获取表写读锁是阻塞, 获取该行的读锁阻塞
2. **其他唯一索引列引起的失败则没加锁: 本/其他 session 无限制**
3. _失败加的是行读锁: 本 session 无限制, 其他 session 此时想获取表写读锁是阻塞, 获取该行的读锁阻塞_

## 4.数据太多: 分库分表

1. 数据量的衡量
2. 垂直分区: 指数据表列的拆分, 把⼀张列⽐较多的表拆分为多张表

   - 减少 I/O 次数, 垂直分区可以简化表的结构,易于维护
   - 主键会出现冗余, 引起 Join 操作[在应⽤层进⾏ Join], 让事务变得更加复杂；

3. ⽔平分区: ~~表结构不变, 每⼀⽚数据分散到不同的库中~~ Sharding-JDBC

   - ⽀持⾮常⼤的数据量存储, 应⽤端改造也少, 但 分⽚事务难以解决
   - 跨节点 Join 性能差, 逻辑复杂
