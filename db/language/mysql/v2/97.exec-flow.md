## 关键字执行过程

### Join

1. 子查询
2. join 原理: a join b --> join c

   - left join: 如果可以命中索引, 就会先使用 索引 过滤一下数据, 之后才会进行 join;
   - left join: 如果没有则会先做 join 之后根据 where 对 join 之后的结果进行过滤

3. 小表在前的原理:

   - 最终产生的 row 不会变化, 但是过程中时不一样的 cost
   - 左表就一条记录, join 右表则是顺序读

4. a left join b ?? b left join a

   - 如果 where 条件中含有 table_b 的非空条件[除开 is null] 会被优化成笛卡尔积的 join, 否则按照 SQL 执行
   - 优化器回去比较这两种的 cost: `scan a' cost[io+cpu] + a's rows[某个地方记录的近似值] * b's cost`

5. calculate a's cost between all-scan and index: io+cpu

   - 全表扫描的 cost: rows \* 读取一行的 cost + 顺序读
   - 走索引的 cost: 走索引的 cost 会默认认为回表 索引, 扫描该索引的 cost + 索引过滤后的行数 \* 回表时读取一行的 cost + 随机读

6. table_a has index of idx_a and idx_b, how to choose index

   - idx_a's cost: 扫描 idx_a 的 cost + idx_a 过滤后的行数 \* 回表时读取一行的 cost
   - idx_b's cost: 扫描 idx_b 的 cost + idx_b 过滤后的行数 \* 回表时读取一行的 cost
