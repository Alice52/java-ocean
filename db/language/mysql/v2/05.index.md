## index

### 1. 索引简介

1. 定义:

   - **索引是数据结构： `排好序`的快速`查找` `数据结构`**
   - 在数据之外, 数据库还维护了维护了满足特定**查询算法**的数据结构, 这些数据结构以某种方式引用**指向数据**, 就可以在这些数据结构的基础上实现高级查找算法, 这样的数据结构就是索引
   - 实际上 index 也是一张表, 保存了主键与索引字段, 并指向实体表的记录
   - 一般来说索引本身也很大{**一般在内存中**}, 但索引最终还是会以文件形式存储在硬盘上[idb]
   - 选取`b+树`作为存储结构

     ![avatar](/static/image/db/mysql-b+tree.png)

2. 分类 2: 尽量使用 `复合索引`; 不要超过 5 个;

   ![avatar](/static/image/db/mysql-index-v2.png)

   - `聚簇索引/非聚簇索引`
     1. 回表
     2. 覆盖索引
   - 单值索引/主键索引/唯一索引/复合索引{允许有空值且可以重复}
     1. 索引下推: 5.7
     2. 最左匹配

   ![avatar](/static/image/db/mysql-index-concept.png)

3. 相关概念

   - innodb 是将索引与数据放在一起的: `innodb 在插入数据时, 数据必须和某个索引列放在一起`
   - 在不同存储引擎中数据的组织形式也是不同的, myisam 索引与数据是分开放的: 所以 myisam 只有非聚簇索引
   - 聚簇索引: 数据和索引放在一起的叫聚簇索引
   - 非聚簇索引: 数据和索引不放在一起的叫非聚簇索引, **要查 2 颗 b+树**

4. 优点

   - 类似大学图书馆建书目索引, 提高数据检索效率, 降低数据库 io 成本
   - 通过索引列对数据进行排序, 降低数据排序成本, 降低了 cpu 的消耗

5. 缺点

   - `[空间]`实际上 index 也是一张 table, 保存了主键与索引字段, 并指向实体表的记录, `需要一定的空间`
   - `[修改代价]`index 虽然提高了 query 的速度, 但是却降低了 `update/insert/delete` 的效率: `当 update/insert/delete 时就需要处理 data 和 index 两个部分`
   - `[建立索引难]`需要花时间去建立优秀的 index

6. 使用

   - 适合创建索引

     1. pk: 主键自动建立唯一索引
     2. `频繁作为查询`的条件的字段应该创建索引
     3. 查询中与其他表关联的字段, `外键关系建立索引`
     4. 查询中`排序的字段`, 排序字段若通过索引去访问将大大提高排序的速度
     5. 分组字段
     6. 单值/复合索引的选择问题: **在高并发下倾向创建复合索引**

   - 不适合创建索引

     1. 表记录`太少`
     2. `where` 条件里用不到的字段不创建索引
     3. `频繁更新`的字段不适合创建索引: 因为每次更新不单单是更新了记录还会更新索引, 加重 io 负担
     4. 数据`重复`且`分布平均`的表字段: 如果某个数据列包含许多重复的内容, 为它建立索引就没有太大的实际效果

7. 索引选择

   - 单表: `where 顺序无关`

     ![avatar](/static/image/db/mysql-index.png)

   - order by: 尽量使用 index 方式排序, 避免使用 filesort 方式排序

     ![avatar](/static/image/db/mysql-order-by.png)

     1. 符合最佳左前缀法则
     2. 复合升序降序排序会使用 using filesort
     3. order by 中间不能断, 且**可以和 where 之后一起不断也可以**
     4. 当无法使用索引列, 增大 max_length_for_sort_data 参数的设置 + 增大 sort_buffer_size 参数的设置

   - group by

     1. group by 实质是先排序后进行分组
     2. 遵照索引建的最佳左前缀
     3. where 高于 having, 能写在 where 限定的条件就不要去 having 限定
     4. 当无法使用索引列, 增大 max_length_for_sort_data 参数的设置 + 增大 sort_buffer_size 参数的设置

8. [索引使用建议](./98.optimize.md)

9. syntax

   ```sql
   -- 1. create index
   create [unique] index index_name on table_name(column_name);
   alter table table_name add [unique] index [index_name] on table_name(column_name);
   -- unique and not null
   alter table table_name add primary key(column_name)
   -- unique and can null, and null can more times
   alter table table_name add unique index_name(column_name)
   -- common index, can more time one value
   alter table table_name add index index_name(column_name)
   -- use in full text search
   alter table table_name add fulltext index_name(column_name)

   -- 2. delete index
   drop index [index_name] on table_name

   -- 3. show  index
   show index from table_name
   ```

### 2. 为什么 使用 b+ 树

1. hash 的缺点

   - hash 算法影响比较大, 而且 hash 碰撞可能导致数据不均匀, 可能是链表
   - hash 不支持范围查询: 必须逐个匹配
   - 需要大量的空间

2. avl/二叉树/红黑树

   - 都是树, 每个节点只有两个节点
   - 导致深度变深[io 次数变多查询变慢]
   - 局部性原理: 时间局部性和空间局部性, 数据和程序都有聚集成群的倾向, 之前读取过的数据可能会被再次读取的可能性大
   - 磁盘预读: 如果从磁盘中读取 a 字符并不是直接读取 a 字符的; 内存和磁盘进行数据交互的时候有一个最基本的数据单元[页一般 4/8k], 每次读取的时候应该是页大小的整数倍, innodb 默认每次读取 16k 数据

3. b 树

   ![avatar](/static/image/db/mysql-index-b.png)

4. b+ 树:

   ![avatar](/static/image/db/mysql-index-b+.png)
