[toc]

## [Reactor](https://blog.csdn.net/larry_zeng1/article/details/78867992)

0. C10K 问题
1. Event + Handler: 对 IO 时间的抽象[fd 的抽象] + 回调处理器
   - 事件驱动: 事件触发的时执行(比如你的工资到账的时候, 有短信通知你, 而不是疯狂查看余额)
   - 不 IO 复用时, 判断读事件则只能阻塞; IO 复用可以在内核层面通知我们 --> multiplexer
   - 将 Acceptor 注册进去 demultiplexer 中; 当有连接到来时, Acceptor 被触发, 然后触发 Acceptor 的 handler, 获得新的 fd, 包装成事件, 重新注册成新的事件, 再次被注册到 demultiplexer 中; 然后接连处理
2. demultiplexer[分离器]: 对 epoll/select 的抽象

3. Reactor[反应堆]

   - 当一个事件开始驱动时, 就会陆续驱动多个事件, 最后就像核反应堆一样, 从而实现`高效地处理并发`
   - 核心: `IO复用+非阻塞编程+bind/function`
   - 至于如何拆分事件和粒度则不是 reactor 的思想[设计原则]

4. 举例说明: `TcpConnection = receive - process - send`

   - 正常处理, 要求当前线程必须处理完整个过程才能处理下个连接
   - Reactor 可以将其拆分成独立的: 处理 receive, process, send 彼此完全解耦, 只是有顺序关系
     - 当前线程处理完 receive, 然后将 process 注册到事件中, 然后处理下个连接

5. select 的问题: `解决一个线程处理多个连接的问题`

   ```c
   // r表示我们对哪些fd的可读事件感兴趣
   // w表示我们对哪些fd的可写事件感兴趣
   select(int nfds, fd_set *r, fd_set *w, fd_set *e, struct timeval *timeout)
   // 调用前这3个集合表示我们感兴趣的事件, 调用后这3个集合表示实际发生的事件
   ```

   - r,w,e 的 FD_SETSIZE 大小: 通常为 1024
   - 由于这 3 个集合在返回时会被内核修改, 因此我们`每次调用时都需要重新设置`
   - 在调用完成后需要全量的扫描这 3 个集合才能知道哪些 fd 的读/写事件发生: 效率比较低下
   - `内核`的每次调用都需要`扫描传递[无状态]`这 3 个 fd 集合, 看 fd 的事件是否发生: 存在效率问题

6. poll

   ```c
   poll(struct pollfd *fds, int nfds, int timeout)

   struct pollfd {
      int fd;
      // 感兴趣的事件
      short events;
      // 实际发生的事件
      short revents;
   }
   ```

   - poll 没有传递固定大小的 bitmap: select 1 的问题解决
   - poll 将感兴趣的事件和实际的事件分开: select 2 的问题解决
   - 问题 3 没有解决: select 问题 3 比较容易解决, `只要系统调用返回的是实际发生相应事件的fd集合`
   - 问题 4 没有解决: 无状态 --> 有状态[在第一次调用的时候记录这些 fd, 然后我们在以后的调用中不需要再传这些 fd]

7. epoll ~~& kqueue~~: `有状态`

   ```c
   // 创建一个context: 状态保存者
   int epoll_create(int size);
   // 将新的感兴趣的fd的读/写事件更新到context中
   int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
   // 等待context中fd的事件发生
   int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
   ```

   - 解决了 select 的问题

   ![avatar](/static/image/common/reactor-common.png)

8. reactor & redis

   - 事件分类: 文件事件和时间事件
   - 文件事件: `服务器对套接字操作的抽象`

     1. 客户端的 GET 请求对于服务器来说就是一个文件事件

   - 时间事件: `服务器定时或周期性执行的事件`

     1. RDB 持久化

   - core code

     ```c#
     int main(int argc, char **argv) {
        ...
        // 建立各个事件处理器
        initServer();
        ...
        // 执行事件处理循环
        aeMain();
        ...
        // 关闭停止事件处理循环
        aeDeleteEventLoop(server.el);
        return 0;
     }
     ```
