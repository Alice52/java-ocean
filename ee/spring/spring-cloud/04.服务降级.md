## 服务降级

### 1. Hystrix[deprecate]`[tomcat thread pool(10) CONSUMER]`

1. feature

   - 服务降级
   - 服务熔断
   - 服务监控
   - 服务限流
   - 服务隔离

2. 定义

   - 用于处理分布式系统的`延迟和容错的`开源库, 保证在一个模块出问题下, 不会出现整个服务失败**`[避免连坐(级联故障)]`**, 也不会导致级联故障, 以提高分布式系统的弹性

3. 断路器理念:

   - 是一种开关装置, 当某个服务单元发生故障时, 通过 `断路器的` **故障监控**, 向服务的调用方返回**`一个符合预期的, 可处理的备选响应[FallBack]`**
   - 而不是长时间等待或者抛出调用方无法处理的异常
   - 这样就保证了服务调用方的线程长时间, 不必要的占用, 从而避免故障在分布式系统中蔓延, 乃至产生雪崩

4. concept

   - [请 10s 后再试]服务降级: fallback = 预期可处理的备选响应

     - 程序运行时异常
     - 超时
     - 服务熔断触发
     - 线程池/信号量打满

   - [拒绝提供服务]服务熔断: break

     - 达到最大访问量时, 而拒绝提供服务
     - 之后调用服务降级方法, 返回友好提示
     - flow: **`熔断 --> 降级 --> 恢复链路调用`**

   - [闸机 QPS]服务限流: flowlimit

     - 秒杀等高并发操作, 严禁拥挤, 排队, 1s N 个, 有序进行

5. 当遇到高并发时, 在一个模块下的不同的方法都会变慢: 使用 JMTER 模拟高并发

   - tomcat 的默认工作线程数被打满, 没有多余的线程来缓解压力和处理请求
   - 大部分的资源被拿去处理高并发的请求, 则导致了本来很快的方法也会变慢

   - code

   ```java
   /**
   * the two method will aslo become slow due to high concurrent<br>
   *
   * @author zack <br>
   * @create 2020-04-02 22:30 <br>
   */
   public interface PaymentService {
      /**
         * this service is mock success call.<br>
         *
         * @param id
         * @return String
         */
      String getPaymentInfo(String id);

      /**
         * this service is mock failed call.<br>
         *
         * @param id
         * @return String
         * @throws InterruptedException
         */
      String getPaymentInfoTimeout(String id) throws InterruptedException;
   }
   ```

6. fallback: `hystrix uses it's own thread pool`

   - hystrix mostly used in client
   - fallback

     - provider fallback: provider 系统定义一个服务的峰值时间, 超过就触发 fallback 做服务降级

       - the paramter must be same as service, otherwise will 404
       - it should be in service impl, rather than interface

     - consumer fallback

7. coding

   - should config global fallback handler:
     - `@DefaultProperties(defaultFallback = "globalOrderFallbackHandler")` in caller class
     - and `@HystrixCommand()` in caller method
   - and the fallback should be organized in one place: `should handle in FeignService, otherwise it's call is scattered`

     - implement FeignClient interface, and do fallback in this class
     - before

     ```java
     // FeignClient interface
     @Component
     @FeignClient(value = "CLOUD-PROVIDER-PAYMENT-HYSTRIX")
     public interface HystrixService {
         @GetMapping("/payment/hystrix/success-info") JsonResult getPaymentInfos();
         @GetMapping("/payment/hystrix/fail-info") JsonResult getPaymentInfoTimeout();
     }

     // caller
     @RestController
     @RequestMapping(value = "/consumer")
     @DefaultProperties(defaultFallback = "getPaymentInfoTimeoutHandler")
     public class OrderController {
         @Resource private HystrixService hystrixService;

         // use defaultFallback
         @GetMapping("/hystrix/success-info")
         @HystrixCommand()
         public JsonResult getPaymentInfo() { return hystrixService.getPaymentInfos(); }

         // use specify fallback
         @GetMapping("/hystrix/fail-info")
         @HystrixCommand( fallbackMethod = "getPaymentInfoTimeoutHandler",
                 commandProperties = { @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "2000") })
         public JsonResult getPaymentInfoTimeout() { return hystrixService.getPaymentInfoTimeout(); }

         public JsonResult getPaymentInfoTimeoutHandler() { return new JsonResult(200, message, null); }
     }
     ```

     - after: 解耦

     ```yml
     # this is used with @FeignClient(value = "CLOUD-PROVIDER-PAYMENT-HYSTRIX", fallback = HystrixServiceHandler.class), otherwise consumer will loss fallback
     # it will make @HystrixCommand() annotation in caller[controller] make no sense, and it no help to timeout issue
     feign:
       hystrix:
         enabled: true
     ```

     ```java
     @Component
     @FeignClient(value = "CLOUD-PROVIDER-PAYMENT-HYSTRIX", fallback = HystrixServiceHandler.class)
     public interface HystrixService {
         @GetMapping("/payment/hystrix/success-info") JsonResult getPaymentInfos();
         @GetMapping("/payment/hystrix/fail-info") JsonResult getPaymentInfoTimeout();
     }

     // HystrixServiceHandler
     @Component
     public class HystrixServiceHandler implements HystrixService {
         @Override public JsonResult getPaymentInfos() { return new JsonResult(400, "getPaymentInfos", null);}
         @Override public JsonResult getPaymentInfoError() { return new JsonResult(400, "getPaymentInfoError", null); }
     }

     // caller
     @RequestMapping(value = "/consumer")
     public class OrderController {
         @Resource private HystrixService hystrixService;

         @GetMapping("/hystrix/success-info")
         // @HystrixCommand() notice: this will be not work if enable feign.hystrix
         public JsonResult getPaymentInfo() { return hystrixService.getPaymentInfos(); }

         @GetMapping("/hystrix/fail-info")
         public JsonResult getPaymentInfoTimeout() { return hystrixService.getPaymentInfoTimeout(); }
     }
     ```

8. timeout issue: **`[expensive]hystrix: if provider and consumer all do service fallback:`**

   - provider fallback timeout: 3s, but the method execute cost 5s, so it will trigger this fallback in 3s
   - consumer fallback timeout: 4s, so what happened?

     - phenomenon is consumer triggered itself fallback when 1s, why??

   - **`the question is cause by ribbon and hystrix timeout issue`**
   - this is because ribbon default timeout is 1s, and hystrix default timeout is also 1s, so if change the args with 1s, everything is fine
   - if the args is more than 1s, should do follow change

     - consumer client should add the below code: **`because hystrix and ribbon work together, it will determine by that shortest`**

     ```yml
     ribbon:
       # the time should more than provider service
       ReadTimeout: 3500
       connectionTimeout: 3500
     ```

   - if consumer hystrix timeout set 20s, and ribbon timeout set 40s; provider hystrix time set 30s, and method execute costs 50s, so consumer will trigge itself fallback when 20s
   - if consumer hystrix timeout set 40s, and ribbon timeout set 20s; provider hystrix time set 30s, and method execute costs 50s, so consumer will trigge itself fallback when 20s

9. 服务熔断: 达到最大访问后直接拒绝访问, 调用 fallback

   - introduce

     - 熔断机制是`应对雪崩效应`的一种微服务链路保护机制
     - **`[5s-20times]`**当扇出链路的某个微服务`出错`和调用`时间过长`时会进项服务降级, 进而`熔断该节点`的微服务调用, `快速`返回错误的响应信息
     - 当检测到该节点的微服务调用响应正常时, `恢复链路调用`

   - state

     - open: 请求不在进行调用当前服务, 内部设置时钟一般为 MTTR(平均故障处理时间), 当打开时长达到所设时钟则进入半熔断状态
     - half open: 部分请求根据当前规则调用当前服务, 如果请求成功, 且符合规则, 则认为当前服务恢复正常, 关闭熔断
     - closed: 熔断关闭, 不会对该服务进行熔断
       ![avatar](/static/image/spring/cloud-circuit-breaker.png)

   - code

   ```java
   // circuitBreaker.requestVolumeThreshold: 在 sleepWindowInMilliseconds 内达到峰值次数且 errorThresholdPercentage 大于设置会触发熔断
   // and need enable @EnableCircuitBreaker in xxApplication
   @Override
   @HystrixCommand(
       fallbackMethod = "paymentCircuitBreakerHandler",
       commandProperties = {
           @HystrixProperty(name = "circuitBreaker.enabled", value = "true"),
           @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "10"),
           @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "10000"),
           @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "60")
       })
   public String paymentCircuitBreaker(Integer id) {
       if (id < 0) throw new RuntimeException();
       String message = "Thread Pool: " + IdUtil.simpleUUID();
       return message;
   }

   public String paymentCircuitBreakerHandler(Integer id) { return "Id cannot less than zero, please try later!"; }
   ```

   - [workflow](https://github.com/Netflix/Hystrix/wiki/How-it-Works)

     1. 当满足一定的阈值的时候[10s - 20requests]
     2. 且失败率达到设置[10s - 50%]
     3. 断路器将会开启
     4. 熔断器开启后, 所有请求都不进行转发: 直接调用 fallback 进行降级
     5. 一段时间后[5s], 此时熔断器半开, 会让其中的一个请求转发
     6. 如果成功, 断路器会关闭; 若失败继续开启, 重复 4-5

     ![avatar](/static/image/spring/cloud-hystrix-command-flow.png)

10. 服务限流
11. 服务监控: this work for the method, which enable circuit breaker

    - `the dashboard should be see after circuit breaker method called, otherwise it maybe 503`
    - pom: dash board

    ```xml
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    ```

    - code: provider [404]

    ```java
    /**
    * when spring cloud upgrate, then ServletRegistrationBean default is bot /hystrix.stream due to
    * spring boot<br>
    *
    * @return ServletRegistrationBean
    */
    @Bean
    public ServletRegistrationBean getServlet() {
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings("/hystrix.stream");
        registrationBean.setName("HystrixMetricsStreamServlet");
        return registrationBean;
    }
    ```

    - description
      ![vatar](/static/image/spring/cloud-hystrix-dashboard.png)

      - 7 颜色: `Success | Short-Circuited | Bad Request | Timeout | Rejected | Failure | Error %`
      - 1 圈:
        - 颜色: 表示健康程度 [绿色 --> 黄色 --> 橙色 --> 红色]
        - 大小: 故障实例和高压测试
      - 1 线

### 2. Resilience4j[recommend]

### 3. Sentinel[recommend]

1. ## 概述

   - 分布式系统的流量防卫兵
   - Sentinel 以流量为切入点
   - 从流量控制, 熔断降级, 系统负载保护等多个维度保护服务的稳定性

   ![avatar](/static/image/spring/alibab-sentinel.png)

2. feature

   - 服务雪崩
   - 服务降级
   - 服务熔断
   - 服务限流

3. install
   - java -jar xx.jar
   - run in docker
   ```yml
   sentinel:
     image: registry.cn-shanghai.aliyuncs.com/alice52/dev-sentinel:20200414.289f92f
     restart: on-failure
     container_name: dev-sentinel
     ports:
       - 8849:8080
   ```

---

## conlusion

1. hystrix 和 sentinel 的区别
   - hystrix 需要自己搭建监控平台: 9001
   - sentinel 自带 UI, 可以进行更加细粒度的配置控制, 如: 可以进行流控, 速率控制, 服务熔断
   - sentinel 可以独立作为服务

---

## 补充

1. 服务雪崩

   - 扇出: 多个微服务之间调用的时候, 假设 A 调用 B, C; B, C 由分别调用其他的微服务
   - 服务雪崩: 如果扇出上某个微服务调用时间过长或者不可用, 则对微服务 A 的调用就会占用越来越多的资源, 从而导致系统崩溃
   - 服务雪崩: 当你发现某个模块的某个实例失败后, 该模块还会接受流量, 这个有问题的模块还调用了其他模块， 发生的级联的故障

---

## reference

1. [hystrix usage](https://github.com/Netflix/Hystrix/wiki/How-To-Use)
2. [hystrix work flow](https://github.com/Netflix/Hystrix/wiki/How-it-Works)
3. [alibaba sentinel](https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D)
