## Spring handle exception

1. `@ExceptionHandler`
    - @ExceptionHandler 所处理的类不能重复
    - @ExceptionHandler 修饰的方法的返回值: `ModelAndView/ResponseEntity`

### 1. @Controller + @ExceptionHandler

1. dispatcherServlet#doDispatch

```java
HandlerExecutionChain mappedHandler = null;
Exception dispatchException = null;
ModelAndView mv = null;

try{
    mappedHandler = getHandler(request); // 根据请求查找 handlerMapping 找到 controller
    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());// 找到处理器适配器HandlerAdapter
     
    if(!mappedHandler.applyPreHandle(request, response)){ //拦截器preHandle
        return ;
    }       
    mv = ha.handle(request, response); // 调用处理器适配器执行 @RequestMapping 方法[controller]
    mappedHandler.applyPostHandle(request, response, mv);  // 拦截器 postHandle
}catch(Exception ex){
    dispatchException = ex;
}

// 这个方法一定会被执行
processDispatchResult(request, response, mappedHandler, mv, dispatchException) //将异常信息传入了
```

2. DispatcherServlet#processDispatchResult

```java
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) {

    boolean errorView = false;
    if (exception != null) {
        if(exception instanceof ModelAndViewDefiningException) {
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        } else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler():null);
            // core code
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv !=null);
        }
    }
}
```

3. DispatcherServlet#processHandlerException

```java
protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
    ModelAndView exMv = null;
    // this.handlerExceptionResovlers: 这个是项目启动是注入进来的
    // 通过 `<mvc:annotation-driven />` 或者注解
    for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResovlers) {
        exMv = handleExceptionResolver.resolveException(request, response, handler, ex);
        if(exMv != null) {
            break;
        }
    }
    // ...
}
```

4. AbstractHandlerExceptionResolver#resolveException


```java
public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
    if(shouldApplyTo(request, handler)) {
        if(this.logger.isDebugEnabled()) {
            this.logger.debug("Resolving exception from handler [" + handler + "]: " + ex);
        }

        logException(ex, request);
        // 设置response的Cache-Control
        prepareResponse(ex, response);
        // core code
        return doResolveException(request, response, handler, ex);
    }
}
```

5. AbstractHandlerMethodExceptionResolver#shouldApplyTo implement `AbstractHandlerExceptionResolver#shouldApplyTo`

```java
protected boolean shouldApplyTo(HttpServlet request, Object handler) {

    if(handler == null) {
        return super.shouldApplyTo(request, handler);
    } else if(handler instanceof Handler) {
        HandlerMethod handlerMethod = (HandleMethod) handler;
        handler = handleMetrhod.getBean();
        return super.shouldApplyTo(reqest, handler);
    } else {
        return false;
    }
}

6. AbstractHandlerExceptionResolver#shouldApplyTo


```

### 2. @ControllerAdvice + @ExceptionHandler

### 3. HandlerExceptionResolver

---

## http status

1. json response
2. html reponse

---

## restful api and html error handle mechanism

1. json response
2. html reponse
