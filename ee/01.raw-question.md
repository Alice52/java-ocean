## spring

### 1.validate[aop]

### 2.bean 生命周期

- ioc 容器初始化

  ```java
  public void refresh() throws BeansException, IllegalStateException {
      synchronized (this.startupShutdownMonitor) {
          prepareRefresh();
          ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
          // https://blog.csdn.net/sinat_41900642/article/details/113238236
          prepareBeanFactory(beanFactory);

          try {
              postProcessBeanFactory(beanFactory);
              invokeBeanFactoryPostProcessors(beanFactory);
              registerBeanPostProcessors(beanFactory);
              initMessageSource();
              initApplicationEventMulticaster();
              onRefresh();
              registerListeners();
              finishBeanFactoryInitialization(beanFactory);
              finishRefresh();
          } catch (BeansException ex) {
              destroyBeans();
              cancelRefresh(ex);
              throw ex;
          }
      }
  }
  ```

- bean create -- bean init[对象创建完成且赋值好之后] -- use -- destroy

1. factory

   - BeanDefinitionRegistryPostProcessor

     ```java
     // 时机: 在所有bean定义信息已经被加载, bean实例还未创建的
     // 作用: 给容器中再额外添加一些组件, 在标准初始化之后修改applicationContext的内部bean registry
     public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {
         // BeanDefinitionRegistry Bean定义信息的保存中心
         // 以后BeanFactory就是按照BeanDefinitionRegistry里面保存的每一个bean定义信息创建bean实例
         void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
             // 第一种方式
             RootBeanDefinition beanDefinition = new RootBeanDefinition(Blue.class);
             // 第二种方式
            AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Blue.class).getBeanDefinition();
            registry.registerBeanDefinition("hello", beanDefinition);
         }
     }
     ```

   - BeanFactoryPostProcessor

     ```java
     // 应用: 在策略模式中注入过 OrderHandlerContext{包含一系列的执行策略[Map<String, Class> handlerMap]}
     // 时机: 在BeanFactory标准初始化之后调用，这时所有的bean定义已经保存加载到beanFactory，但是bean的实例还未创建
     // 作用: 给容器中再额外添加一些组件, 修改已有的相关的 beandefinition
     // 注意: 千万不要进行bean实例化[1. 使用注解进行依赖注入失败]
     public interface BeanFactoryPostProcessor {
         void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
             OrderHandlerContext context = new OrderHandlerContext(handlerMap);
             // 注意只能修改 registerbean/beandefinition
             factory.registerSingleton(OrderHandlerContext.class.getName(), context);
         }
     }
     ```

     ```java
     // 在 BeanFactoryPostProcessor 中触发bean创建的影响: beanFactory.getBeansOfType(BBean.class);
     // 1. 使用注解进行依赖注入失败: 原因是使用 AutowiredAnnotationBeanPostProcessor[registerBeanPostProcessors] 来实现 Autowired, 但是创建 bean 时还未执行
     // 解决: 不使用注解方式, 直接使用 xml
     @Component("bBean")
     public class BBean {
         @Autowired private ABean aBean;
     }
     @Component
     public class ABean {}
     ```

2. create instance

   - InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
   - InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation

   ```java
   // 实例化----实例化的过程是一个创建Bean的过程，即调用Bean的构造函数，单例的Bean放入单例池中
   // 初始化----初始化的过程是一个赋值的过程，即调用Bean的setter，设置Bean的属性
   // 主要作用在于目标对象的实例化过程中需要处理的事情, 包括实例化对象的前后过程以及实例的属性设置
   public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {
       // 在目标对象实例化之前调用, 所以这个返回值可以用来代替原本该生成的目标对象的实例[比如代理对象]
       // 如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用
       // 否则按照正常的流程走
       Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException;

       // 在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null
       // 返回值 +  mbd.getDependencyCheck() 都是 false 则不会调用 postProcessPropertyValues
       boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException;

       // 对属性值进行修改: 这个时候属性值还未被设置，但是我们可以修改原本该设置进去的属性值
       PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException;
   }
   ```

3. init bean

   - BeanPostProcessor#postProcessBeforeInitialization

     ```java
     // 时机: 具体为Bean初始化前会回调的方法
     // 应用: 可以实现接口多实现时指定创建谁
     public interface BeanPostProcessor {
         @Nullable
         default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
             return bean;
         }

         @Nullable
         default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
             return bean;
         }
     }
     ```

   - @PostConstruct

     ```java
     // Java自己的注解
     ```

   - InitializingBean#afterPropertiesSet
   - @bean#init
   - BeanPostProcessor#postProcessAfterInitialization

     ```java
     // 时机: 具体为Bean初始化后会回调的方法
     public interface BeanPostProcessor {
         @Nullable
         default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
             return bean;
         }

         @Nullable
         default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
             return bean;
         }
     }
     ```

   - SmartInitializingSingleton#afterSingletonsInstantiated

4. destroy

   - @PreDestroy
   - DisposableBean#destroy
   - @bean#destroy

### 3.ioc-自动装配

### 4.PropertyValue&PropertyDescriptor

### 4.profile

### 5.property

### 6.aop

### 7.aop-transaction

## mvc

1. 组件的执行顺序

   - Listener
   - Filter: 多个按照定义的顺序执行
   - Interceptor: HandlerInterceptor[使两个自定义的 interceptor 顺序执行 WebMvcConfigurer#addInterceptor]
     1. preHandle: ↓
     - Servlet
     2. postHandler: ↑
     3. afterCompletion: ↑

2. request flow
   - // TODO: mvc 请求流程的源码解读
   - request coming --> dispatchservlet
   - dispatchservlet --> handlerMapping: 返回 handlerExecutionChain
   - dispatchservlet[handlerExecutionChain] --> handlerAdaptor
   - handlerAdaptor --> handler[controller]: ModelAndView
   - [controller]ModelAndView --> dispatchservlet
   - dispatchservlet --> viewresolver: 返回 view[dispatchservlet]
   - view --> front code --> response

## boot

### 1.spring boot exception strategy

### 2.starter + spi

### 3.tomcat-undertow

### 4.cache
