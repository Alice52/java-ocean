## 单例模式 Singleton

1. 定义: 保证一个类全局只有一个, 并提供获取实例的访问点
2. 使用场景:
   - 重量级对象, 不需要要实例: 线程池, 数据库连接池
3. UML 图

   ![avatar](/static/image/pattern/pattern_singleton_uml.png)

### 实现方式: 8

1. 饿汉式[线程安全·可用]

   - smaple

     ```java
     // 类加载过程: 连接#准备时分配内存初始化默认值, 初始化时设置初值
     private static HungrySingleton instance = new HungrySingleton();
     private HungrySingleton() {}
     public static HungrySingleton getInstance() {
         return instance;
     }
     ```

   - 类一加载的时候, 就实例化, 提前占用了系统资源

2. 常量式[线程安全·可用]

   - smaple

     ```java
     // jvm 加载过程保证线程安全
     private ConstantSingleton() {}
     public static final ConstantSingleton instance = new Singleton();
     public static ConstantSingleton getInstance() {
         return instance;
     }
     ```

   - 类一加载的时候, 就实例化, 提前占用了系统资源

3. 懒汉式[线程不安全·并发场景不可用]

   - 延时加载, 在真正使用的时候才会实例化

   - smaple

     ```java
     private static LazySingleton instance;

     public static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
     }
     ```

4. 同步的懒汉式[线程安全·可用·不建议使用]

   - smaple

     ```java
     // 8-lock
     private static LazySingleton instance;
     public static synchronized LazySingleton getInstanceThreadSafe() {
        if (instance == null) {
            instance = new LazySingleton();
        }

        return instance;
     }
     ```

5. **双重检查锁 DCL**[线程安全·大多数场景满足需求·推荐使用]

   - smaple

     ```java
     // volatile
     // DCL
     private static volatile LazySingleton instance;
     public static LazySingleton getInstanceThreadSafeV2() {
         if (instance == null) {
             synchronized (LazySingleton.class) {
                 if (instance == null) {
                     instance = new LazySingleton();
                 }
             }
         }

         return instance;
     }
     ```

6. 静态内部类[线程安全·推荐使用]

   - sample

     ```java
     // 内部类: 线程安全是靠 jvm 加载保证的
     // 懒加载
     private InnerSingleton() {}
     private static class InnerClassSingleton {
         private static InnerSingleton instance = new InnerSingleton();
     }
     public static InnerSingleton getInstance() {
         return InnerClassSingleton.instance;
     }
     ```

7. 枚举单例[线程安全·不建议使用]

   - sample

     ```java
     // 线程安全 + 反射创建会直接报错
     public enum EnumSingleton {
         INSTANCE;
     }
     ```

   - 相比于静态常量 Enum 会花费两倍以上的内存

8. 利用容器实现单例[线程安全·不建议使用]

### 单例模式的应用场景

1. Spring
2. JDK

---

## Notice

1. 防止反射破坏单例

   - 上面的所有单例的实现在通过反射创建时都是线程不安全的

   ```java
   @SneakyThrows
   @Test
   public void testReflect() {
       Constructor<HungrySingleton> constructor = HungrySingleton.class.getDeclaredConstructor();
       constructor.setAccessible(true);

       HungrySingleton hungrySingleton = constructor.newInstance();
       HungrySingleton instance = HungrySingleton.getInstance();

       Assert.isFalse(instance == hungrySingleton);
   }
   ```

   - 使用 **饿汉式 || 静态内部类** 可以修改 code 做反射防护

     ```java
     private static HungrySingleton instance = new HungrySingleton();
     private HungrySingleton() {
         if (instance != null) {
             throw new RuntimeException("singleton instance is not null");
         }
     }
     public static HungrySingleton getInstance() {
         return instance;
     }
     ```

2. 防止序列化和反序列化破坏单例

## Reference

1. https://www.cnblogs.com/joy99/p/9859764.html
