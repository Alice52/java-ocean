- 程序 = 数据结构+算法

## 代码评判

1. **可维护性**[maintainability]
   - 在不破坏原有代码设计, 不引入新的 bug 的情况下, 能够快速地修改或者添加代码
   - 扩展性和可读性有的时候是相冲突的
2. **可读性**[readability]:
   - 与机器的运行效率一定程度上的冲突
   - 命名 + 设计 + 注释 + 编码规范 + 模块划分 + 封装多态继承
3. **`可扩展性`**[extensibility]
   - 对修改关闭, 对扩展开放: 功能扩展点
   - 抽象复用
4. 简洁性[simplicity]: KISS
   - _思从深而行从简_
5. **可复用性**[reusability]
   - 继承/多态/设计[如适配器模式等]
6. 日志问题
7. 可测试性[testability]
   - 写单元测试容易
   - 单元测试不能依赖于环境: h2 内存数据库

## 代码质量细节

1. 目录模块划分是否清晰, 代码结构是否满足"高内聚、松耦合"
2. 遵循设计原则和思想: SOLID、DRY、KISS、YAGNI、LOD
3. 设计模式使用得当
4. 代码评判

## 相关概念

1. 面向对象:
   - 封装[信息隐藏或者数据访问保护]、抽象[封装的具体实现,隐藏细节,扩展]、继承[**代码复用**,go 没有]、多态
   - 充血模型
   - 接口 & 抽象
   - 组合 & 继承
   - 是很多设计原则、设计模式等编码实现的基础
2. 设计原则
   - 代码设计中一些经验的总结: 对于某些场景下, 是否应该应用某种设计模式, 具有指导意义
3. 设计模式
   - 经常遇到的一些设计问题, 总结出来的一套解决方案或者设计思路
4. 编程规范
   - 代码的可读性问题, 落地细节
   - 持续的小重构依赖的理论基础主要就是编程规范
5. 重构
   - 保持代码质量

![avatar](/static/image/pattern/design-guideline.png)

## 重构

- 重构: 最小原型 + 两顶帽子

1. 一般性步骤
   - 提高代码的可读性: oop & principle
   - 提高代码的可测试性: 非 static
   - 编写完善的单元测试: 单元测试用例如何写, 关键看你如何定义函数
   - 所有重构完成之后添加注释
2. 函数出错应该返回
   - ~~返回错误码~~: c 这种语言再用, 不好
   - 异常对象: 是否往上抛要看上层是否关心这个异常
     1. 直接吞掉 + log
     2. re-throw
     3. 包装成新的异常 re-throw
   - NULL 值
     1. 空指针异常
     2. 与业务耦合: 个人看法还是查不到返回 NULL 或者 EMPTY, 而不是 Throw 异常
   - 空对象: **空对象设计模式**

---

### OOP

- 本质: 把合适的代码放到合适的类中

1. 封装
   - What: 隐藏信息, 保护数据访问
   - How: 暴露有限接口和属性, 需要编程语言提供访问控制的语法.
   - Why: 提高代码可**维护**性; 降低接口复杂度, 提高类的**易用性**.
2. 抽象
   - What: **隐藏具体实现**, 使用者只需关心功能, **无需关心实现**.
   - How: 通过接口类或者抽象类实现, 特殊语法机制非必须.
   - Why: 提高代码的**扩展性**、维护性; 降低**复杂度**, 减少**细节**负担.
3. 继承
   - What: 表示 is-a 关系, 分为单继承和多继承
   - How: 需要编程语言提供特殊语法机制. 例如 Java 的 `extends`, C++ 的 `:`
   - Why: 解决代码**复用**问题, is-a, 多态的重写, 但是带来了继承层次过深等阅读和维护的代价
   - solution: 组合[composition]、接口、委托[delegation]
4. 多态
   - What: 父类的引用指向子类的实现
   - How: 重写 & 重载
   - Why: 提高代码**扩展**性和**复用**性
5. 实现步骤
   - 划分职责进而识别出有哪些类
   - 定义类及其属性和方法
   - 定义类与类之间的交互关系
   - 将类组装起来并提供执行入口: 上帝视角的类
