## HashMap

1. HashMap

   - Key 可以为 null 但是不能重复, 重复会覆盖原来的值
   - 底层: 数组 + 链表 + 红黑树, hash 作为 key, Entry 作为 value
   - 线程不安全

2. put

   - 计算关于 key 的 hashcode 值（与 Key.hashCode 的高 16 位做异或运算）
   - 如果散列表为空时，调用 resize()初始化散列表
   - 如果没有发生碰撞，直接添加元素到散列表中去
   - 如果发生了碰撞(hashCode 值相同)，进行三种判断

     1. 若 key 地址相同或者 equals 后内容相同，则替换旧值
     2. 如果是红黑树结构，就调用树的插入方法
     3. 链表结构，循环遍历直到链表中某个节点为空
        - **尾插法**进行插入
        - 插入之后判断链表个数是否到达变成红黑树的阙值 8 且整体大于 length64[树化(双向链表+红黑树)]；
        - 也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖
        - 小于 6 的时候会去树化

   - 如果桶满了大于阀值，则 resize 进行扩容

   ![avatar](/static/image/java/javase-hashnap-put.png)

3. resize()

   - 发生场景
     1. 初始化数组 table
     2. 当数组 table 的 size 达到阙值时即 `++size > load factor * capacity` 时，也是在 putVal 函数中
   - 过程
     1. 通过判断旧数组的容量是否大于 0 来判断数组是否初始化过, 进行初始化: 大于该值的 2 的次幂树
     2. 大于 int 最大值则不再扩容
     3. 否则直接扩容 2 倍, 将元素复制到新的数组, Arrays.Copy()/System.CopyArray(origin, o_start, dest, dest_start, length)
     4. 2 的次幂数的存在导致只可能出现的元下标位置和+length 的长度 hash & length
     5. 可能会发生去树化 6

4. get

   - 查询数据相对来说就⽐较简单了，⾸先计算出 hash 值，然后去数组查询，是红⿊树就去红⿊树查，链表就遍历链表查询就可以了。

5. 为什么不直接将 key 作为哈希值而是与高 16 位做异或运算

   - 算下标的时候是低位参与的 & 运算
   - 此时让高位参与, 使得散列均匀, 减少 hash 碰撞

6. 为什么是 2 的次幂数

   - 为了数据的均匀分布，减少哈希碰撞[hash 是的散列操作]
   - 出现的位置

7. 平时在使用 HashMap 时一般使用什么类型的元素作为 Key

   - Integer，String 这种不可变的类型，线程安全
   - 如果使用对象的一定要重写 hashCode()以及 equals()

8. JDK 7 & 8

   - 数据结构
   - 扩容时机: > throshold 且要插入的位置不为 null 才扩容
   - hash 算法
   - rehash 的问题: 默认是 int 最大值&jvm 参数配置的

9. HashMap 和 HashTable 的区别

   - 相同点：都是存储 key-value 键值对的
   - 不同点：

     1. HashMap 允许 Key-value 为 null，hashTable 不允许；
     2. hashMap 没有考虑同步，是线程不安全的。hashTable 是线程安全的，给 api 套上了一层 synchronized 修饰;
     3. HashMap 继承于 AbstractMap 类，hashTable 继承与 Dictionary 类。
     4. 迭代器(Iterator)。HashMap 的迭代器(Iterator)是 fail-fast 迭代器，而 Hashtable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出 ConcurrentModificationException。
     5. 容量的初始值和增加方式都不一样：HashMap 默认的容量大小是 16；增加容量时，每次将容量变为"原始容量 x2"。Hashtable 默认的容量大小是 11；增加容量时，每次将容量变为"原始容量 x2 + 1"；
     6. 添加 key-value 时的 hash 值算法不同：HashMap 添加元素时，是使用自定义的哈希算法。Hashtable 没有自定义哈希算法，而直接采用的 key 的 hashCode()。

## ConcurrentHashMap
