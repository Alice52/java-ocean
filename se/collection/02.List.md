## List

1. introduce

   ![avatar](/static/image/java/javase-collection-list-struct.png)

2. API:

   ```java
   void add(int index, Object element)                   // O(1): System.arraycopy
   boolean addAll(int index, Collection elements)
   Object get(int index)                                 // O(1)
   int indexOf(Object obj)                               // 获取指定元素的索引值 charAt(int i)
   int lastIndexof(Object obj)                           // i = size - 1 往回遍历
   Object remove(int index)                              // O(1): System.arraycopy
   Object set(int index, Object element)                 // replace
   List subList(int fromIndex, int toIndex)
   ```

3. List 的遍历:

   ```java
   List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3));

   // 1. 超级 for 循环遍历
   for(int attribute : list) {
       System.out.println(attribute);
   }

   // 2. 对于 ArrayList 来说速度比较快, 用 for 循环, 以 size 为条件遍历:
   for(int i = 0 ; i < list.size() ; i++) {
       System.out.println(list.get(i));
   }

   // 3. 集合类的通用遍历方式, 从很早的版本就有, 用迭代器迭代
   Iterator it = list.iterator();
   while(it.hasNext()) {
       System.out.println(it.next());
   }

   // 4.Stream()
   list.stream().forEach(System.out::println);
   ```

4. List 中元素的排序:

   ```java
   Collections.sort(persons, new Comparator<Person>() {
       @Override
       public int compare(Person o1, Person o2) {
           return o1.getAge().compareTo(o2.getAge());
       }
   });
   Person sortByAge = Collections.min(persons, Comparator.comparingInt(Person::getAge));
   Person sortByName = Collections.min(persons, Comparator.comparing(Person::getName));
   ```

5. List & Generic

   ```java
     // 1. List<Object> objList 不是 List<String> strList 的父类
     //    - 泛型擦除引起的: 字节码中都是 Object
     // 2. 可以使用 <? extends Person>
   public void testGeneralAndList() {
     List<String> strList = Arrays.asList("AA", "BB");
     // List<Object> objList = strList; // compile error

     printPersonInfo(persons);
     // printPersonInfo(students);  // compile error
     printStudentInfo(students);
   }

   public static void printStudentInfo(List<? extends Person> students) {
     students.forEach(System.out::println);
   }

   @Deprecated
   public static void printPersonInfo(List<Person> persons) {
     persons.forEach(System.out::println);
   }
   ```

6. [Thread](../thread-advance/interview/list.md)

   - 线程不安全
   - `Vector/Collections#synchronizedList(List)/CopyOnWriteArrayList` 线程安全

7. ConcurrentModificationException

   ```java
   List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3));
   list.forEach(
       x -> {
         list.add(1);
         log.info("element: {}", x);
       });
   ```

### Source Code

1. 数据结构: 底层是数组

   ```java
   transient Object[] elementData; // non-private to simplify nested class access
   ```

2. 初始化: 默认初始化时长度是 10

   ```java
   private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

   public ArrayList() {
       this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
   }

   public ArrayList(int initialCapacity) {
       // some-logic
       this.elementData = new Object[initialCapacity];
   }
   ```

3. add(T t): 会触发初始化和扩容问题

   ```java
   // 1. 如果使用无参构造函数创建数组, 则第一次 add 元素时会分配空间 10
   // 2. 如果使用有参构造函数创建数组, 则空间分配发生在创建数组时
   // 3. 接下来就是考虑数组扩容
   //     - 判断 elementData 是否有空余空间, 有就存放
   //     - 没有则扩容 1.5 倍[Arrays.copyOf]之后存放
   private static final int DEFAULT_CAPACITY = 10;

   public boolean add(E e) {
       ensureCapacityInternal(size + 1);  // Increments modCount!!
       elementData[size++] = e;
       return true;
   }

   private void ensureCapacityInternal(int minCapacity) {
       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
   }

   private static int calculateCapacity(Object[] elementData, int minCapacity) {
       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
           return Math.max(DEFAULT_CAPACITY, minCapacity);
       }
       return minCapacity;
   }

   private void ensureExplicitCapacity(int minCapacity) {
       modCount++;

       // overflow-conscious code
       if (minCapacity - elementData.length > 0)
           grow(minCapacity);
   }

   private void grow(int minCapacity) {
       int oldCapacity = elementData.length;
       int newCapacity = oldCapacity + (oldCapacity >> 1);
       if (newCapacity - minCapacity < 0)
           newCapacity = minCapacity;
       if (newCapacity - MAX_ARRAY_SIZE > 0)
           newCapacity = hugeCapacity(minCapacity);
       elementData = Arrays.copyOf(elementData, newCapacity);
   }
   ```

4. get(int index):

   ```java
   public E get(int index) {
       rangeCheck(index);
       return elementData(index);
   }

   private void rangeCheck(int index) {
       if (index >= size)
           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
   }
   ```

5. remove(int index): 缩容问题, 将 index 之后的元素前移动一位

   ![avatar](/static/image/java/javase-collection-list-arraylist-grow.png)

   ```java
   // elementData.length 不会变
   public boolean remove(Object o) {
       if (o == null) {
           for (int index = 0; index < size; index++)
               if (elementData[index] == null) {
                   fastRemove(index);
                   return true;
               }
       } else {
           for (int index = 0; index < size; index++)
               if (o.equals(elementData[index])) {
                   fastRemove(index);
                   return true;
               }
       }
       return false;
   }

   private void fastRemove(int index) {
       modCount++;
       int numMoved = size - index - 1;
       if (numMoved > 0)
           System.arraycopy(elementData, index+1, elementData, index,
                            numMoved);
       elementData[--size] = null; // clear to let GC do its work
   }
   ```

6. modCount:
   - 每次修改或者新增是就会 ++
   - 防止一遍新增一遍查看: `ConcurrentModificationException`

### Tools

1. Array to List

   - Arrays: 只能查不能修改添加

     ```java
     // 只能查不能修改添加
     //   1. Arrays#asList 返回值是 java.util.Arrays.ArrayList
     //   2. 返回值并没有实现  AbstractList#add(Object) 方法
     //   3. UnsupportedOperationException
     public void array2ListByArrays() throws UnsupportedOperationException {
       List<Integer> integers = Arrays.asList(1, 2, 3);
       List<int[]> ints = Arrays.asList(new int[] {1, 2, 3});
     }
     ```

   - ArrayList: 可以进行任意操作

     ```java
     // 利用 ArrayList 构造函数将 java.util.Arrays.ArrayList 转换为 java.util.ArrayList
     public static void array2ListByArrayList() {
       ArrayList<Integer> integers = new ArrayList<>(Arrays.asList(1, 2, 3));
       integers.add(4);
       integers.forEach(System.out::println);
     }
     ```

   - `Collections.addAll()`: 效率最高

     ```java
     // 使用 Collections#addAll() 效率最高
     public static void array2ListByCollections() {
       List<Integer> integers = new ArrayList<>();
       boolean success = Collections.addAll(integers, 1, 2, 3);
       integers.forEach(System.out::println);
     }
     ```

2. List to Array

   - toArray(T[] t)

     ```java
     public static void list2Array() {
         ArrayList<Integer> integers = new ArrayList<>(Arrays.asList(1, 2, 3));
         Object[] objects = integers.toArray();
         Integer[] array = integers.toArray(new Integer[] {});
         Arrays.stream(array).forEach(System.out::println);
     }
     ```

   - 遍历 List 将元素一个一个放入 Array

3. Distinct List Element

   ```java
    ArrayList<Integer> numbers = new ArrayList<>(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));
   ```

   - LinkedHashSet: 可以保证 unique 和 sequence

     ```java
     LinkedHashSet<Integer> hashSet = new LinkedHashSet<>(numbers);
     ArrayList<Integer> distinctNumbers = new ArrayList<>(hashSet);
     ```

   - stream

     ```java
     List<Integer> distinctNumbers = numbers.stream().distinct().collect(Collectors.toList());
     ```

   - HashSet: 保证 unique 之后搞一个新的 List 保证顺序

     ```java
     HashSet<Integer> set = new HashSet<>(numbers.size());
     List<Integer> result = new ArrayList<>(numbers.size());
     for (Integer i : numbers) {
       if (set.add(i)) {
         result.add(i);
       }
     }

     numbers.clear();
     numbers.addAll(result);
     ```

   - contains: 将结果保存到新的 List 中

     ```java
     List<Integer> result = new ArrayList<>(numbers.size());
     for (Integer str : numbers) {
       if (!result.contains(str)) {
         result.add(str);
       }
     }
     numbers.clear();
     numbers.addAll(result);
     ```

   - 双重 for

     ```java
       for (int i = 0; i < numbers.size(); i++) {
       for (int j = 0; j < numbers.size(); j++) {
         if (i != j && numbers.get(i).equals(numbers.get(j))) {
           numbers.remove(numbers.get(j));
         }
       }
     }
     ```

### Interview

1. Vecter & ArrayList

   - 都是基于数组实现的
   - 默认容量都是 10
   - Vector 可以自定义扩容长度[capacityIncrement 创建时指定], 否则是扩容 2 倍
   - Vector 是线程安全的: synchronized[效率低]
