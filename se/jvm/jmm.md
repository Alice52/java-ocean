## JMM

### 概念

1. JMM 概念:

   - Java 内存模型, 本身时一种抽象概念, `不真实存在`,
   - 描述一组`规则和规范`, 通过这组规范定义了程序中的各个变量`[包含实例字段, 静态字段和构成数组对象的元素]`的访问方式
   - 为了屏蔽各种硬件和操作系统的内存访问差异, 以实现让 Java 程序在各种平台下都能达到一致的内存访问效果
   - JMM 规定了所有的变量都存储在主内存[Main Memory]中, 每条线程还有自己的工作内存[Working Memory]

2. JMM 规定

   - 线程解锁前, 必须吧共享变量的值刷新汇主内存
   - 线程加锁前, 必须读取主内存的最新值到自己的工作内存
   - 加锁解锁时同一把锁

3. flow

   - JVM 运行程序的实体时线程, 而每个线程创建时 JVM 都会为其创建一个工作内存[栈空间], 工作内存时每个线程私有的数据区域
   - JMM 中规定所有的变量都存储在`主内存`: `主内存` 是共享内存区域, 所有线程都可以访问
   - 但是线程对变量的操作[读取修改], 都必须在自己的工作内存中: 所以首先需要将变量从主内存拷贝到自己的工作内存空间, 然后对变量进行操作, 完成操作后在写回主内存, `不能直接操作主内存中的变量`
   - 各个线程中工作内存中存储着主内存中变量副本的拷贝, 因此不同的线程件无法访问对方的工作内存,
   - 线程间的通信[传值]必须通过主内存来完成

   ![avatar](/static/image/java/JMM.bmp)

4. jmm feature

   - 可见性:
     1. `线程A在自己的工作空间内修改值后刷新会主内存, 之后会通知其他线程的机制就是可见性`
     2. 解决: volatile || sunchronized || final
   - 原子性[两个操作之间不能加塞 || 两个操作要么一起成功要么一起失败**且顺序执行**]: `完整性, 不可分割`
     1. 定义: 某个线程正在做某个具体的业务时, 中间不可以被加塞或者分割, 需要整体完整, 要么成功, 要么失败
     2. 解决: 锁 || CAS || OS 做
   - 有序性
     1. 指令重排序导致乱序执行[遵循 as-if-serial: 不管怎么重排序, 单线程环境下程序的执行结果不能被改变]
     2. CPU 和编译器不会对存在数据依赖关系的操作做重排序
     3. 不同 CPU 之间和不同线程之间的数据依赖性是不被 CPU 和编译器考虑的
     4. 解决: volatile || sunchronized || Happens-before

### Happens-before

1. 简介
   - 它是判断数据是否存在竞争，线程是否安全的非常有用的手段
   - 是理解 JMM 的关键

---

## 补充

1. 物理磁盘, 内存, CPU[只负责计算]
2. 主内存是物理内存条
