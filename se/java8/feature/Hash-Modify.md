## HashMap

### JDK 1.7

- 核心: 数组[默认 16 个元素] + 链表
- 具体实现:
  通过计算这个值的 `hashCode`, 之后运算为数组的索引, 若该索引值无内容, 则直接填入; 否则, 使用 `equals` 运算, 相等就取代; 不等时就生成链表放入`头结点`. 当哈希因子大于 0.75 时, 扩容数组之后对所有的元素重新运算并放入新的数组, 以此减少 `哈希碰撞`.
- 哈希因子: 默认是 0.75
- 减少哈希碰撞: `重写 hashCode 和 equals 方法`

### JDK 1.8

- 核心: 数组[默认 16 个元素] + 链表 + 红黑树
- 具体实现:
  在 JDK 1.7 的基础上, 把新加元素添加到链表的`尾节点`, 当哈希碰撞时链表内元素大于 `8` 且总元素大于 `64` 时, 就会将链表转换为 `红黑树`.
- JDK 1.8 该插入在链表的 `头结点` 为 `尾结点` 是因为在 JDK 1.7 多线程时会出现环导致的死循环.
- 红黑树的优点:
  - 增删改查的效率会提高
  - 数组扩容时, 不需要将 hashCode 重新运算为 数组的索引: `要么在原先的index上, 要么在 index + old_length 上`

## ConcurrentHashMap

### JDK 1.7

- 核心: 锁分段机制, 一共 16 段, 每段里有一个链表: 16 元素
- ConcurrentLevel[默认的并发级别]: 16

### JDK 1.8

- 核心: 去除段机制, 采用 `CAS` 算法

## 底层内存结构

### JDK 1.7

- 栈:
- 堆: 垃圾的回收区
- 方法区(堆的永久区[PremGen]): 存放一些类信息、核心类库. `几乎不会被 GC 回收`

### JDK 1.8

- 栈:
- 堆: 垃圾的回收区
- 元空间[MetaSpace]: 直接使用电脑的物理内存, 堆的永久区被取消
